<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[变量]]></title>
    <url>%2Fposts%2F13ffbe88%2F</url>
    <content type="text"><![CDATA[变量的显示与设置 设置变量和Python等脚本语言一样，在shell里，使用变量之前并不需要事先为它们做出声明，只是通过使用它们(比如当你给它们赋初始值时)来创建它们。 1VARIABLE_NAME=value 显示变量的内容通过在变量名前加一个$符号来访问它的内容。一种检查变量内容的简单方式就是在变量名前加一个$符号，再用echo命令将它的内容输出到终端上。 12echo $变量名echo $&#123;变量名&#125; 取消变量 1unset 变量名 变量的约定 引号的使用变量之间以空白字符(例如，一个空格，一个制表符或者一个换行符)分隔，如果变量内容包含一个或多个空白字符，必须给变量加上引号。像$foo这样的变量在引号中的行为取决于你所使用的引号类型。 双引号把$变量表达式放在双引号中，程序执行到这一行时会把变量替换为它的值，如var=&quot;long is $LONG&quot;，则echo $var可得long is en_US。 单引号把$变量表达式放在单引号中，不会发生替换现象，如ar=&quot;long is $LONG&quot;，则echo $ar可得long is $LONG。还可以在$字符前面加上一个\字符取消它的特殊含义。 所以字符串通常都放在双引号中，以防止变量被空白字符分开，同时又允许$扩展。 为了增加一个变量的内容时，则可用$变量名或${变量名}累加内容，如下所示： 1$ PATH=$PATH:/home/bin `…`或$(...)获取子进程输出在一串命令中，还需要使用通过其他命令提供的信息，可以使用反引号`命令`或$(命令)。在一串命令内，在``之内或$()之内的命令将会被先执行，而执行的结果将作为外部的输入信息。 12$ echo `uname -r`4.4.0-66-generic 环境变量当一个shell脚本开始执行时，一些变量会根据环境设置中的值进行初始化，这些变量称为环境变量。环境变量通常用大写字母做名字，而用户在脚本程序里定义的变量通常用小写字母做名字。 下面列出了一些主要的环境变量 HOME当前用户的家目录。 PATH以冒号分隔的用来搜索命令的目录列表。系统通过PATH这个变量里面的内容所记录的路径来查找某个需要执行的命令。所以你能不能在任何目录下执行某个命令与PATH这个变量有很大的关系。如果在找完PATH变量内的路径还找不到ls这个命令时，就会在屏幕上显示&quot;commond not found&quot;的错误信息。 $0shell脚本的名字 $$shell脚本的PID(进程号)。脚本程序通常会用它来生成一个唯一的临时文件，如/tmp/tmpfile_$$。 显示环境变量 env是environment(环境)的简写，功能是列出所有的环境变量 set查看所有变量，包含环境变量和自定义变量 临时导入自定义变量export 自定义变量子进程会继承父进程的环境变量，但子进程不会继承父进程的自定义变量。执行export 变量名可以让该自定义变量在子进程中使用。但只在当前父进程及其子进程有用，当父子进程全部退出，该自定义变量也不再保留。 source 自定义环境变量在脚本中 export 自定义的环境变量如果在shell脚本中export环境变量，执行完脚本后，查看该环境变量竟然看不到。 为什么在shell脚本里用export环境变量之后，当shell执行完了，用set命令看不到呢？但是如果直接在终端里export环境变量用set是可以看到的？ 这里的关键在于理解shell脚本的执行方法。当执行一个shell脚本时，是在当前终端所在的shell fork出一个子shell执行该脚本，执行完毕再返回终端所在的shell。因此在脚本中设置了环境变量，它只在fork出来的子shell以及该子shell的子shell，也就是子shell和子子shell中生效，子shell只能继承父shell的环境变量，而不能修改父shell的环境变量，所以子shell执行结束，父shell的环境变量没有改变，看不到脚本中设置的环境变量的值。 解决办法那么如何让脚本的环境变量在脚本执行之后仍然对当前终端存在呢？用source或.(dot)。明确告诉shell不要fork执行脚本，而是在当前的shell执行，这样环境变量就可以保存下来了。 source 命令用法： 12source filename # (source 通常用.来代替)source test.sh # 与 . test.sh 是相同的 永久导入自定义变量HOME目录下的.profile文件用来保存当前用户设置的环境变量。通过编辑.profile文件，在里面通过export语句导入自定义的变量，可以永久导入该自定义的变量。 1export MAIL_USERNAME="15091521590@163.com" 该语句永久导入用户自定义的MAIL_USERNAME变量。]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的模块与包]]></title>
    <url>%2Fposts%2F125cf81d%2F</url>
    <content type="text"><![CDATA[模块什么是模块在Python中，一个.py文件就是一个模块，一般情况下，模块的名字就是文件名，但是不带.py后缀。举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。模块的名字保存在全局变量__name__中。模块可以被导入到其他模块，也可以被导入到主模块(main module)。主模块是脚本在顶层或计算器模式下执行时你能访问的所有变量的集合，也就是说当该模块作为脚本执行时它就是被导入到主模块。前面提到，一般情况下，模块的名字就是文件名，而当模块作为脚本执行时，就是特殊情况。当模块作为脚本执行时，__name__被设置为__main__。__main__是顶层代码执行作用域的名字。通过判断__name__的值，我们可以知道模块是否正在被当做脚本执行，同样也可以选择性地执行某些代码：123if __name__ == '__main__': # execute only if run as a script # you code is here 模块的命名空间模块化组织代码有很多好处，实现功能分割与解耦，提高代码的可维护性。其次，模块的代码可以在其他地方引用等等。其中很重要的一点就是可以避免函数名和变量名冲突。每一个模块有自己的私有符号表，保存在模块自己的命名空间中(此处为个人总结，可能有错误！)。对于模块内部的函数而言，这个私有符号表就是全局符号表，因此可以自由访问模块中定义的变量。同时不同模块各自拥有独立的私有符号表，这就使不同模块的作者不用担心自己模块中使用的变量名会和其他作者模块中的变量名冲突。 导入模块导入模块的两种方式Python提供了至少两种方式导入一个模块。 import X导入模块X，并且以X的命名空间为名字将X中定义的变量导入到当前的命名空间。换而言之，在你执行这个语句之后，你能用X.name引用模块X中定义的对应变量。 from X import *导入模块X，并且直接以X中定义的变量名为名字将X中定义的公有变量(名字不是以下划线_开头的变量)导入到当前的命名空间。换而言之，当你执行玩这个语句之后，你可以直接使用变量名，而不用加X.前缀来引用模块X中定义的对应变量。但是模块名X本身没有被定义，所以X.name这样形式的语句是错误的。同时，如果在此之后改变了模块X中某些变量的定义，在当前的命名空间中不会进行更新。注意import *是一种不建议使用的写法，因为它引入的变量名可能会与当前命名空间中之前已经定义过的变量名同名，产生命名冲突，从而覆盖掉之前同名变量的定义，这是一个让人很难检查出的问题。在交互式环境，如IPython，Python自带的shell等环境下，可以使用这种写法。 from X import a, b, c这个其实仍然属于第二种方式，导入模块X，并且直接以X中定义的变量名为名字将X中给定的公有变量导入到当前的命名空间。换而言之，你可以在程序中使用a，b，c这三个变量。 导入模块的内部机制当Python导入一个模块时，它首先在模块注册表(sys.modules)中检查是否有该模块，如果有则直接从已经存在的模块对象的命名空间中按照对应的import语句导入变量。如果该模块不存在，它的执行流程如下： 创建一个新的空的模块对象，此时该模块的命名空间为空 将该模块对象插入到sys.modules字典 加载该模块代码，必要时先变异该模块 在该模块的命名空间下执行模块中的代码，代码中所有被定义的变量(包括变量，函数，类)都将被添加到模块的命名空间里 也就是说，当模块第一次被正在执行的脚本导入时，Python会转而执行该模块中的代码来初始化该模块的命名空间。当其他模块第二次导入该模块时，由于该模块已经存在于模块注册表sys.modules中，它将不会被再次加载，所以模块中定义的变量仅仅被初始化了一次。 循环导入(Cirular Imports)当执行import语句导入模块时，程序将转而执行该模块中的代码，而模块中定义的变量，比如def，class还不存在于模块的命名空间直到执行到def或class对应的定义语句，它们才会被添加到命名空间。考虑这样一种情况：在模块X中将导入模块Y，同时定义了一个名为spam的函数：12345# module Ximport Ydef spam(): print('function in module X') 如果在主程序中导入模块X，Python将加载X的代码并执行它。当遇到import Y语句时，它将加载模块Y的代码并跳转到Y执行。此时，Python已经将X和Y添加到了模块注册表sys.modules中，但是此时X的命名空间还为空，不包含任何变量，而import Y之后紧跟的def spam函数定义也没有执行。如果模块Y中又导入了X，就构成了循环导入，而循环导入极有可能产生错误。当模块Y又导入X时，它将首先检查sys.modules，此时X已经存在，所以它将引用X空的命名空间，因为X的命名空间为空，所以此时任何尝试访问X.spam的语句，都将产生错误。12# module Yfrom X import spam # doesn't work: spam isn't defined yet! 同样下面的代码也会遇到错误：1234# module Yimport XX.spam() # doesn't work either: spam isn't defined yet! 要解决这个错误，有两种方法： 将模块X和Y中都要引用的变量定义移动到一个独立的文件中，X和Y都从这个文件中引用需要的变量 将import语句移动到模块的结尾如果将模块X中的import Y语句移动到结尾，可以解决这个问题。 模块的搜索路径当导入一个名为spam的模块时，Python的搜索顺序如下： 在内置模块(bulit-in module)查找对应的模块名 未命中，则在sys.path列表给出的目录列表中查找名为spam.py的文件而sys.path以下面的先后顺序进行初始化： 添加输入脚本所在的目录(如果没有指定脚本则为当前目录) 添加系统变量PYTHONPATH指定的目录列表，PYTHONPATH类似与shell变量PATH 添加Python的安装路径的目录 注意，在初始化sys.path之后，Python会修改sys.path，将执行脚本所在的目录放在搜索列表的最前面，位于标准库目录的前面。这就意味着当脚本所在目录存在和标准库模块同名的模块时，Python将加载脚本所在目录的模块而不是标准库中的模块，这也是一个常见的不好排查的错误。为了避免自己定义的模块与标准库冲突，从而需要引入包的概念。 包什么是包包是一种通过”dotted module names”的引用方式来构造模块命名空间的方法。Python中的包是一个目录但必须包含一个特殊的名为__init__.py的文件，最简单的该文件可以为空，也可以包含该模块的初始化代码或设置__all__变量的值。该文件表明该目录是一个可导入的包，而不是一个普通目录。就像，模块名A.B在一个名为A的包中指定了一个名为B的子模块。通过引入模块，使不同模块的作者不用担心彼此模块中的全局变量名产生冲突。类似的，引入包采用”dotted module names”的方式使不同的多模块包的作者不用担心彼此模块名产生冲突。 导入包导入包的不同形式 from package import itemitem可以是一个子模块或子包，也可以是package中定义的函数，类或变量。该语句首先检查item是不是package中定义的变量(package所在目录下的init.py文件中是否有item变量的定义)，如果不是，则假设item是一个模块，并尝试加载它，如果失败，会抛出ImportError异常。 import item.subitem.subsubitem除了最后一个subsubitem，其余的所有的item,subitem都必须是一个包，最后一个subsubitem可以是一个模块或者包，但不能是subitem中定义的函数，类或变量。 from package import *如果__init__.py中定义了一个列表变量__all__，将导入与__all__中包含的所有字符串同名的那些模块。如果__init__.py中没有定义__all__，并不会像from module import *会导入模块中所有公有变量到当前命名空间那样，导入包中含有的所有子模块到当前命名空间。而是仅确保该包名被导入，同时如果__init__.py不为空还执行其中的代码，这样就又会导入__init__.py文件中定义的所有名字，包括其中通过import语句导入的模块名。比如下面的例子：包的结构如下：12345678910|- A/ |- __init__.py |- a.py |- b.py |- c.py |- B/ |- __init__.py |- a.py |- b.py |- c.py 在A/所在目录下进入交互式环境，执行from B import *代码，而A/B/__init__.py内容如下：123print('Subpackage B init.')import afrom B import b 输出如下：1Subpackage B init. 继续执行：123456&gt;&gt;&gt; B&lt;module 'B' from '/home/qiuyu/code/Web/moduleNameSpace/A/B/__init__.py'&gt;&gt;&gt;&gt; B.a&lt;module 'a' from '/home/qiuyu/code/Web/moduleNameSpace/A/a.py'&gt;&gt;&gt;&gt; B.b&lt;module 'B.b' from '/home/qiuyu/code/Web/moduleNameSpace/A/B/b.py'&gt; 由于是从A/所在目录进入交互式环境的，所以sys.path搜索目录列表的第一项是A/所在的目录，所以import a导入的是A/目录下的a.py模块，而from B import b首先检查到b不是包B中定义的变量，所以假设b是一个模块而尝试导入它，这样就导入了A/B/b.py模块。 包内引用/相对导入当一个包中含有子包时，你可以通过在当前包中通过绝对导入引入兄弟包中的模块，也可以通过相对导入来引入模块。相对导入使用”leading dots”来指示当前包和父包。“.”表示当前包所在目录，”..”表示父包所在目录。所以上面的from B import b也可以改写为from .B import b。注意，**相对导入依赖于当前模块的名字。当该模块作为主模块导入时，其__name__的值为__main__，而__main__没有提供模块的真实名字，不能使用相对导入。也就是说，当一个模块作为主模块使用时，只能使用绝对导入。 参考文献 Importing Python Modules Modules and Packages - Learn Python - Free Interactive Python Tutorial 模块 - 廖雪峰的官方网站 6. Modules — Python 3.6.2 documentation 29.4. main — Top-level script environment — Python 3.6.2 documentation]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
        <category>语法基础</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>Package</tag>
        <tag>Import</tag>
        <tag>Cirular Imports</tag>
        <tag>Relative Imports</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
</search>