<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[python的模块与包]]></title>
    <url>%2Fposts%2F125cf81d%2F</url>
    <content type="text"><![CDATA[basic footnote1 1. 模块1.1 什么是模块在Python中，一个.py文件就是一个模块，一般情况下，模块的名字就是文件名，但是不带.py后缀。举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。模块的名字保存在全局变量__name__中。模块可以被导入到其他模块，也可以被导入到主模块(main module)。主模块是脚本在顶层或计算器模式下执行时你能访问的所有变量的集合，也就是说当该模块作为脚本执行时它就是被导入到主模块。前面提到，一般情况下，模块的名字就是文件名，而当模块作为脚本执行时，就是特殊情况。当模块作为脚本执行时，__name__被设置为__main__。__main__是顶层代码执行作用域的名字。通过判断__name__的值，我们可以知道模块是否正在被当做脚本执行，同样也可以选择性地执行某些代码：123if __name__ == '__main__': # execute only if run as a script # you code is here 1.2 模块的命名空间模块化组织代码有很多好处，实现功能分割与解耦，提高代码的可维护性。其次，模块的代码可以在其他地方引用等等。其中很重要的一点就是可以避免函数名和变量名冲突。每一个模块有自己的私有符号表，保存在模块自己的命名空间中(此处为个人总结，可能有错误！)。对于模块内部的函数而言，这个私有符号表就是全局符号表，因此可以自由访问模块中定义的变量。同时不同模块各自拥有独立的私有符号表，这就使不同模块的作者不用担心自己模块中使用的变量名会和其他作者模块中的变量名冲突。 1.3 导入模块1.3.1 导入模块的两种方式Python提供了至少两种方式导入一个模块。 import X导入模块X，并且以X的命名空间为名字将X中定义的变量导入到当前的命名空间。换而言之，在你执行这个语句之后，你能用X.name引用模块X中定义的对应变量。 from X import *导入模块X，并且直接以X中定义的变量名为名字将X中定义的公有变量(名字不是以下划线_开头的变量)导入到当前的命名空间。换而言之，当你执行玩这个语句之后，你可以直接使用变量名，而不用加X.前缀来引用模块X中定义的对应变量。但是模块名X本身没有被定义，所以X.name这样形式的语句是错误的。同时，如果在此之后改变了模块X中某些变量的定义，在当前的命名空间中不会进行更新。注意import *是一种不建议使用的写法，因为它引入的变量名可能会与当前命名空间中之前已经定义过的变量名同名，产生命名冲突，从而覆盖掉之前同名变量的定义，这是一个让人很难检查出的问题。在交互式环境，如IPython，Python自带的shell等环境下，可以使用这种写法。 from X import a, b, c这个其实仍然属于第二种方式，导入模块X，并且直接以X中定义的变量名为名字将X中给定的公有变量导入到当前的命名空间。换而言之，你可以在程序中使用a，b，c这三个变量。 1.3.2 导入模块的内部机制当Python导入一个模块时，它首先在模块注册表(sys.modules)中检查是否有该模块，如果有则直接从已经存在的模块对象的命名空间中按照对应的import语句导入变量。如果该模块不存在，它的执行流程如下： 创建一个新的空的模块对象，此时该模块的命名空间为空 将该模块对象插入到sys.modules字典 加载该模块代码，必要时先变异该模块 在该模块的命名空间下执行模块中的代码，代码中所有被定义的变量(包括变量，函数，类)都将被添加到模块的命名空间里 也就是说，当模块第一次被正在执行的脚本导入时，Python会转而执行该模块中的代码来初始化该模块的命名空间。当其他模块第二次导入该模块时，由于该模块已经存在于模块注册表sys.modules中，它将不会被再次加载，所以模块中定义的变量仅仅被初始化了一次。 1.3.3 循环导入(Cirular Imports)当执行import语句导入模块时，程序将转而执行该模块中的代码，而模块中定义的变量，比如def，class还不存在于模块的命名空间直到执行到def或class对应的定义语句，它们才会被添加到命名空间。考虑这样一种情况：在模块X中将导入模块Y，同时定义了一个名为spam的函数：12345# module Ximport Ydef spam(): print('function in module X') 如果在主程序中导入模块X，Python将加载X的代码并执行它。当遇到import Y语句时，它将加载模块Y的代码并跳转到Y执行。此时，Python已经将X和Y添加到了模块注册表sys.modules中，但是此时X的命名空间还为空，不包含任何变量，而import Y之后紧跟的def spam函数定义也没有执行。如果模块Y中又导入了X，就构成了循环导入，而循环导入极有可能产生错误。当模块Y又导入X时，它将首先检查sys.modules，此时X已经存在，所以它将引用X空的命名空间，因为X的命名空间为空，所以此时任何尝试访问X.spam的语句，都将产生错误。12# module Yfrom X import spam # doesn't work: spam isn't defined yet! 同样下面的代码也会遇到错误：1234# module Yimport XX.spam() # doesn't work either: spam isn't defined yet! 要解决这个错误，有两种方法： 将模块X和Y中都要引用的变量定义移动到一个独立的文件中，X和Y都从这个文件中引用需要的变量 将import语句移动到模块的结尾如果将模块X中的import Y语句移动到结尾，可以解决这个问题。 1.3.4 模块的搜索路径当导入一个名为spam的模块时，Python的搜索顺序如下： 在内置模块(bulit-in module)查找对应的模块名 未命中，则在sys.path列表给出的目录列表中查找名为spam.py的文件而sys.path以下面的先后顺序进行初始化： 添加输入脚本所在的目录(如果没有指定脚本则为当前目录) 添加系统变量PYTHONPATH指定的目录列表，PYTHONPATH类似与shell变量PATH 添加Python的安装路径的目录 注意，在初始化sys.path之后，Python会修改sys.path，将执行脚本所在的目录放在搜索列表的最前面，位于标准库目录的前面。这就意味着当脚本所在目录存在和标准库模块同名的模块时，Python将加载脚本所在目录的模块而不是标准库中的模块，这也是一个常见的不好排查的错误。为了避免自己定义的模块与标准库冲突，从而需要引入包的概念。 2. 包2.1 什么是包包是一种通过”dotted module names”的引用方式来构造模块命名空间的方法。Python中的包是一个目录但必须包含一个特殊的名为__init__.py的文件，最简单的该文件可以为空，也可以包含该模块的初始化代码或设置__all__变量的值。该文件表明该目录是一个可导入的包，而不是一个普通目录。就像，模块名A.B在一个名为A的包中指定了一个名为B的子模块。通过引入模块，使不同模块的作者不用担心彼此模块中的全局变量名产生冲突。类似的，引入包采用”dotted module names”的方式使不同的多模块包的作者不用担心彼此模块名产生冲突。 2.2 导入包2.2.1 导入包的不同形式 from package import itemitem可以是一个子模块或子包，也可以是package中定义的函数，类或变量。该语句首先检查item是不是package中定义的变量(package所在目录下的init.py文件中是否有item变量的定义)，如果不是，则假设item是一个模块，并尝试加载它，如果失败，会抛出ImportError异常。 import item.subitem.subsubitem除了最后一个subsubitem，其余的所有的item,subitem都必须是一个包，最后一个subsubitem可以是一个模块或者包，但不能是subitem中定义的函数，类或变量。 from package import *如果__init__.py中定义了一个列表变量__all__，将导入与__all__中包含的所有字符串同名的那些模块。如果__init__.py中没有定义__all__，并不会像from module import *会导入模块中所有公有变量到当前命名空间那样，导入包中含有的所有子模块到当前命名空间。而是仅确保该包名被导入，同时如果__init__.py不为空还执行其中的代码，这样就又会导入__init__.py文件中定义的所有名字，包括其中通过import语句导入的模块名。比如下面的例子：包的结构如下：12345678910|- A/ |- __init__.py |- a.py |- b.py |- c.py |- B/ |- __init__.py |- a.py |- b.py |- c.py 在A/所在目录下进入交互式环境，执行from B import *代码，而A/B/__init__.py内容如下：123print('Subpackage B init.')import afrom B import b 输出如下：1Subpackage B init. 继续执行：123456&gt;&gt;&gt; B&lt;module 'B' from '/home/qiuyu/code/Web/moduleNameSpace/A/B/__init__.py'&gt;&gt;&gt;&gt; B.a&lt;module 'a' from '/home/qiuyu/code/Web/moduleNameSpace/A/a.py'&gt;&gt;&gt;&gt; B.b&lt;module 'B.b' from '/home/qiuyu/code/Web/moduleNameSpace/A/B/b.py'&gt; 由于是从A/所在目录进入交互式环境的，所以sys.path搜索目录列表的第一项是A/所在的目录，所以import a导入的是A/目录下的a.py模块，而from B import b首先检查到b不是包B中定义的变量，所以假设b是一个模块而尝试导入它，这样就导入了A/B/b.py模块。 2.2.2 包内引用/相对导入当一个包中含有子包时，你可以通过在当前包中通过绝对导入引入兄弟包中的模块，也可以通过相对导入来引入模块。相对导入使用”leading dots”来指示当前包和父包。“.”表示当前包所在目录，”..”表示父包所在目录。所以上面的from B import b也可以改写为from .B import b。注意，**相对导入依赖于当前模块的名字。当该模块作为主模块导入时，其__name__的值为__main__，而__main__没有提供模块的真实名字，不能使用相对导入。也就是说，当一个模块作为主模块使用时，只能使用绝对导入。 参考文献 Importing Python Modules Modules and Packages - Learn Python - Free Interactive Python Tutorial 模块 - 廖雪峰的官方网站 6. Modules — Python 3.6.2 documentation 29.4. main — Top-level script environment — Python 3.6.2 documentation 1.basic footnote content ↩]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
        <category>语法基础</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>Package</tag>
        <tag>Import</tag>
        <tag>Cirular Imports</tag>
        <tag>Relative Imports</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
</search>