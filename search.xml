<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈DP动态规划]]></title>
    <url>%2Fposts%2F951ae76d%2F</url>
    <content type="text"><![CDATA[1. LeetCode题目：Unique Binary Search Tree先从LeetCode的一个题目：96. Unique Binary Search Trees来引入大名鼎鼎的DP动态规划。题目描述： Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?For example,Given n = 3, there are a total of 5 unique BST’s.123451 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 1. 1. 简单样例分析先对n = 1~4的简单情况进行分析，看看是否可以找出解题思路。 n = 1只有一个元素，为BST的根节点： 11 此时，$NUM(n) = 1$ n = 2分别将1, 2作为根节点，同时满足BST的性质，容易得到： 1231 2 \ / 2 1 此时，$NUM(n) = 2$ n = 3分别将1, 2, 3作为根节点，根据题目提示有： 123451 1 2 3 3 \ \ / \ / / 2 3 1 3 1 2 \ / \ / 3 2 2 1 此时，$NUM(3) = 5$观察以上三种情况，可以发现：n = 2的结果可以基于n = 1的结果得到，而n = 3的结果可以又可以基于n = 2和n = 1的结果得到，如下所示： n = 2其中用虚方框框出来的便是来自n = 1的结果的简单变形：只是改变了n = 1结果中BST的起始值。 n = 3虚方框框出了来自n = 1结果的变形，虚圆圈圈出了来自n = 2的简单变形，这两种变形组合在一起构成了n = 3的结果。并且，根节点是作为切分点的，也就是说，对于n = 3的问题，如果此时根节点为i，则将原问题切分为左右两部分：左边的$NUM((i-1)-1+1)$以及右边的$NUM(n-(i+1)+1)$。这样原来1~n的问题$BSTs(1, n)$分解为三个子问题$BSTs(1, i-1)$，$BSTs(i, i)$，$BSTs(i+1, n)$的组合。而根节点的取值是从1到3，所以对于n = 3的问题，其BST树的个数为$NUM(3) = \sum_{i=1}^{3} NUM(i-1)*NUM(1)*NUM(3-i)$，从而可以推出对于规模为n的问题，其BST树的个数为：$NUM(n) = \sum_{i=1}^{n} NUM(i-1)*NUM(1)*NUM(n-i)$。这里$NUM(n) = \sum_{i=1}^{n} NUM(i-1)*NUM(1)*NUM(n-i)$这个递推式，很好反映了动态规划的第一个显著特征最优子结构(Optimal Substructure)：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。从公式我们可以看出，对于规模为n的问题的解可以由规模更小的分别为i-1，1，n-i的子问题的解相乘再依次累加得到(i: 1~n)，这个公式是最优子结构的数学描述。同时，我们还可以发现，求解规模为i-1以及规模为n-i的子问题时，这两者都要求解规模更小的子子问题。举例来说，对于n=4的问题，i=2时需要求解规模分别为1和2的子问题，而规模为2的子问题，又要求解规模为1的子子问题，与之前规模为1的子问题发生重叠。这是动态规划的第二个特征重叠子问题：不同的子问题，具有公共的子子问题(子问题的求解是递归进行的，将其划分为更小的子子问题)。最优子结构和重叠子问题是动态规划的两个显著特征，对于一个问题，如果满足这两个特征，就可以使用动态规划。同时这两个特征也说明了动态规划和分治方法的异同：动态规划因为具有最优子结构，而最优子结构又符合分治的思想，所以能用动态规划解决的问题，一定也可以用分治算法递归解决。重叠子问题说明了动态规划注意到了不同子问题之间的重叠情况，所以相比于朴素的分治递归算法，动态规划更加高效。接下来，我们可以借助上面的分析，来求解n=4的情况。 n = 4虚方框框出了来自n = 1结果变形，虚圆圈圈出了来自n = 2的简单变形，三角形圈出了来自n = 3的简单变形，这三种变形组合在一起构成了n = 4的结果。图中标出了对于根节点取1到4的过程中，问题BSTs(1, 4)的分解情况，比如对于i = 1，BSTs(1, 4)分解为BSTs(1, 0)为空，BSTs(1, 1)，BSTs(2, 4)。 1. 2. 分治法递归求解 根据递推公式$NUM(n) = \sum_{i=1}^{n} NUM(i-1)*NUM(1)*NUM(n-i)$，我们很容易得到以下基于分治思想的递归代码，为Python实现： 1234567def gen_BSTs_num(n): if n &lt;= 1: return 1 cnt = 0 for i in range(1, n+1): # i: 1~n cnt += gen_BSTs_num(i-1)*gen_BSTs_num(1)*gen_BSTs_num(n-i) return cnt 1. 3. 动态规划求解 动态规划的英文为Dynamic Programming，简称DP，这里的”programming”指的是一种表格法，并非编制计算机程序。”programming”已经充分说明了动态规划的实现核心：通过表格将每一个子问题的解记录下来，随后再次需要此子问题的解，只需查找保存的结果，而不必重新计算。而要记录下子问题的解在再次需要求解时直接查找，很重要的前提就是必须仔细安排求解顺序，确保在第一次求解子问题时用到的子子问题的解都已经记录下来了。所以，求解顺序也是实现动态规划实现的重要注意点。 一般动态规划有两种等价的实现方法： 带备忘录的自顶向下方法(top-down with memoization) 此方法仍按自然的递归形式编写程序，但过程会保存每个子问题的解。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省计算时间；否则，按照通常方式计算这个子问题。我们称这个递归过程是带备忘的(memoized)，因为它“记住”了之前已经计算出的结果。由于自顶向下方法仍然采用自然的递归形式编写程序，所以我们现在上面递归算法的基础上进行改写，实现该方法，以下仍为Python实现： 1234567891011121314151617def gen_BSTs_num_topDown(n): nums = [None for i in range(n+1)] return gen_BSTs_num_topDown_dp(nums, n)def gen_BSTs_num_topDown_dp(nums, n): if nums[n] != None: return nums[n] if n &lt;= 1: num = 1 else: num = 0 for i in range(1, n+1): # i: 1~n num += gen_BSTs_num_topDown_dp(nums, i-1)*\ gen_BSTs_num_topDown_dp(nums, 1)*\ gen_BSTs_num_topDown_dp(nums, n-i) nums[n] = num return nums[n] 自底向上方法(bottom-up method) 这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题。因而我们可以将子问题按规模排序，按由小到大的顺序求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它(也是第一次遇到它)时，它的所有前提子问题都已求解完成。 此方法就要求我们仔细安排求解顺序，按照规模从小到大顺序求解。该问题需要用来记录子问题的表格是一维的，所以按规模从小到大顺序很简单，就是按照从1到n的顺序。但当表格为二维时，求解顺序就会变得复杂，后面有例子讨论二维的情况。下面给出自底向上的代码实现，仍使用Python： 12345678def gen_BSTs_num_bottomUp(n): nums = [1 for i in range(n+1)] for i in range(2, n+1): cnt = 0 for j in range(1, i+1): cnt += nums[j-1]*nums[i-j] nums[i] = cnt return nums[n] 2. LeetCode题目：Unique Binary Search Trees II上面的题目用来记录子问题解的表格是一维的，比较简单，接下来我们来看下表格是二维的情况。该题目是上面题目的升级版，需要输出所有的BST树。LeetCode题目：95. Unique Binary Search Trees II，题目描述： Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n.For example,Given n = 3, your program should return all 5 unique BST’s shown below.123451 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 上面我们已经得到该问题的递推公式：$BSTs(1, n) = BSTs(1, i-1)*BSTs(i, i)*BSTs(i+1, n)$从公式我们可以看出，要构造一个规模为n的BST树，我们选择规模为1的值为i的子BST树作为根节点，选择规模为i-1的起始值为1的子BST树作为左子树，选择规模为n-i的起始值为i+1的子BST树作为右子树，这样组合之后就完成了该规模为n的BST树的构造。这里有个比较麻烦的问题，就是对于规模为k的问题，程序最终的结果是一系列的起始值为1，终止值为k的BST的列表集合。而对于规模为k+1的问题，其求解需要用到的子问题的起始值却不都是从1开始的，比如根节点为1的情况，子问题BSTs(2, k+1)虽然所有BST树的结构都是和子问题BSTs(1, k)相同的，但BSTs(2, k+1)的起始值为2，而不是1。这就要求我们仔细考虑子问题的解应该如何记录。如果仍用一维表格，那就只能记录起始值1的情况下的解，然后对于需要该子问题的解的场合，如果此时的起始值不是1，就需要遍历该子问题的BST树中的每一个节点，对其值进行修改，以使修改后得到的新的BST树从指定的起始值开始，我最开始就是这样的思路。但这样存在一个很大的问题：对于规模为n的问题，其子问题的解都是一系列的BST树，而对其中某一个子问题的这些BST进行遍历修改以使其满足新的初始值，本身就是很大的工作量也增加了算法的复杂性，并且对其中某一颗BST的遍历修改可能在另一个子问题的同样的BST树中仍会用到，而一维表格并不能存储之前这个已经修改了起始值的BST树，导致在另一个子问题中同样的工作需要再次进行，而且同样的BST树需要再次存储，造成了大量的时间和空间的浪费！所以，是时候考虑多维的表格来存储子问题的解了。 2. 1. 二维存储表格我们已经知道对于规模为n的问题，其解的BST树的个数不止一颗，所以其解是包含了多个BST树的列表集合，并且起始值都是从1开始的。对于列表集合的存放，我们仍将其视为只需要单一的空间，尽管列表集合本身存放了多个BST树，那么对于规模为n的问题，总共需要n个单一空间来存放该问题需要用到的子问题的解，所以需要的存储空间是一维的。这里我们需要将原本一维的存储空间进行维度扩增，改为二维的存储空间。该二维的存储空间不再像一维那样关注n这个问题规模，而是关注每一个子问题的起始值和终止值，因为这两个值本身包含了规模信息，同时也包含了对于构造问题的解非常重要的起始值。这样升级以后，对于规模为n的问题，只要合理安排求解顺序，在求解该问题时，我们需要的每一个子问题的解都已经求解完毕，直接可以使用，并且由于不需要对子问题的进行修改，所以可以直接引用子问题的解，无需再进行复制，实际上相比于一维存储也节省了内存空间。我们以n = 4的例子说明二维表格的结构以及如何进行填充。从上图可以看出，二维表格的行是起始值b，列是终止值e，每一个单元格都是一个列表集合，存储了该起始值和终止值对应的问题的解的所有的BST树，并且只有满足b &lt;= e条件的单元格是合法的，才需要进行填充，不合法的不需要进行处理。表格是按照从右下角(4,4)位置开始逆序填充的，对于每一行是按照从左到右的顺序填充，这样就可以保证对于每一个问题在求解时其所需的子问题都已经求解完毕可以直接使用。根据上图的填充顺序，容易写出该思路对应的代码实现，以下为Python实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Nonedef gen_BSTs(n): if n == 0: return 1, [] ''' BSTMatrix整体是一个(n+1)*(n+1)的二维矩阵， 其中每个元素是一个存放了多个BST树的列表 ''' BSTMatrix = [[[None] for i in range(n+1)] for i in range(n+1)] ''' 从右下角[n][n]位置开始，每一行按照从左向右顺序， 逆序填充BSTsMatrix，同时保证b &lt;= e ''' for b in range(n, 0, -1): # b: n~1 for e in range(b, n+1): # e: b~n # 对角线位置，该列表只有一个BST树， # 而该BST树只有一个元素 if b == e: BSTMatrix[b][e] = [TreeNode(b)] else: # 对于BSTMatrix中无用的位置，比如[0][i], i: 0~n， # 将该位置的列表填充为None，对于有用的位置，需要 # 先将列表清空，为后续填充元素做准备 BSTMatrix[b][e] = [] for i in range(b, e+1): # i: b~e leftList = BSTMatrix[b][i-1] # 防止 i+1 发生越界 if n &lt; i + 1: rightList = [None] else: rightList= BSTMatrix[i+1][e] ''' 对于leftList和rightList中的BST树进行排列组合 ''' for k in range(len(leftList)): for l in range(len(rightList)): # 根节点 BST = TreeNode(i) # 插入左子树 BST.left = leftList[k] # 插入右子树 BST.right = rightList[l] # 将BST加入到BSTMatrix[b][e]中 BSTMatrix[b][e].append(BST) return BSTMatrix[1][n] 2. 2. 分治递归实现前面已经提到过：可以用动态规划解决的问题也一定可以用分治法递归地解决，只不过相比于分治法，动态规划更高效。所以我们也可以用分治法递归地解决该问题。其基本思路还是依赖于已经推出的递推公式：$BSTs(1, n) = BSTs(1, i-1)*BSTs(i, i)*BSTs(i+1, n)$，我们利用递推过程建树，这也是建树的常见方法。基于递推公式，我们可以写出下面的Python代码实现：123456789101112131415161718192021222324252627282930313233class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Nonedef gen_BSTsR(n): BSTList = [] if n == 0: BSTList = [] else: BSTList = gen_BSTsR_s(1, n) return BSTListdef gen_BSTsR_s(b, e): BSTList = [] if e &lt; b: BSTList = [None] return BSTList for i in range(b, e+1): # i: b~e leftList = gen_BSTsR_s(b, i-1) rightList = gen_BSTsR_s(i+1, e) for k in range(len(leftList)): for l in range(len(rightList)): # 根节点 BST = TreeNode(i) BST.left = leftList[k] BST.right = rightList[l] BSTList.append(BST) return BSTList]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划DP</tag>
        <tag>LeetCode</tag>
        <tag>Unique Binary Search Trees</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从快速排序看循环不变量]]></title>
    <url>%2Fposts%2F657eb7c9%2F</url>
    <content type="text"><![CDATA[1. 基本思路大概三年前我第一次知道有个快速排序算法，当时才接触分治思想不久，加上直接是参考国内一些博客的文章，虽然写出了可以正确运行的快排程序，但始终觉得有点雾里看花，无法把握算法的基本思想，这也导致一段时间过后，我在徒手写快排程序，脑子里对算法实现模模糊糊，无法正确写出可行的算法。现在看来，一方面是国内博客的实现有点脱离算法导论里的原始代码，另一方面也是因为还不知道循环不变量，直到因为研究生算法课开始拜读算法导论，才了解到里面的快排实现，以及算法背后的循环不变量，顿时有点豁然开朗的感受，所以说要学习算法分析与设计，只读算法导论一本书就够了。 快排基于分治思想，所以从步骤上也无非是分为三步。以对数组A[p…r]进行排序为例，三步分治过程为： 分解 数组A[p…r]被划分为两个(可能为空)子数组A[p…q-1]和A[q+1…r]，使得A[p…q-1]中的每一个元素都小于等于A[q]，而A[q]也小于等于A[q+1…r]中的每一个元素，其中，计算下标q是划分过程最为重要的部分。 解决 通过递归调用快速排序，对子数组A[p…q-1]和A[q+1…r]进行排序。 合并 因为子数组都是原址排序的，所以不需要合并操作:数组A[p…r]已经有序。 由此可见，快速排序算法最为关键的就在于划分操作，找出作为划分点的下标q，使得q左边的元素都小于等于A[q]，而A[q]也小于等于q右边的元素，我们将A[q]称为主元(pivot element)，所以划分算法的第一步便是确定主元。 一般来说，我们总是选择x=A[r]作为主元，并围绕它来划分A[p…r]。随着程序的执行，数组被划分为4个(可能为空的)区域。在第一轮迭代之前，以及每一次迭代后，这四个区域中的每一个区域都满足一定的性质：对任意数组下标k，有： 若p&lt;= k &lt;= i，则A[k] &lt;= x 若i+1 &lt;= k &lt;= j-1，则A[k] &gt; x 若k == r，则A[k] == x 若j &lt;= k &lt; r，对应位置的值与主元之间不存在特定的大小关系 这四个区域满足的性质，就是快速排序的循环不变量。根据该循环不变量，我们可以容易写出如下的划分程序，以下为Python代码实现。至于其中的原因，我想大家看到代码很容易理解吧，比如当A[j] &lt;= x时，此时A[j]可以补充到小于等于x的那部分，而相应的此时A[i+1]要么是大于x的，直接与A[j]交换，此后j进行了加1，自然能保证A[j-1]&gt;x的；要么i+1==j，此时，等于交换A[j]本身，此后j加1，仍然满足A[j-1]&gt;x。以下为Python实现：12345678910def partition(A, p, r): i = p - 1 x = A[r] for j in range(p, r): # j:[p, r-1] if A[j] &lt;= x: i += 1 A[i], A[j] = A[j], A[i] # swap A[i] with A[j] i += 1 A[i], A[r] = A[r], A[i] return i 我们以在一个样例数组上的划分过程来直观观察该循环不变量。 i=p-1, j=p, x=A[r] 12345678i p,j r 0 1 2 3 4 5 6 7 | 2 | 8 | 7 | 1 | 3 | 5 | 6 | 4 |i = -1, j = 0, x = 4A[j] = 2 &lt; 4i = i + 1 = -1 + 1 = 0swap A[i] with A[j] &lt;===&gt; swap A[0] with A[0] 初始状态下，i=p-1和j=p，因为在p和i之间，i+1和j-1之间都不存在值，所以循环不变量的前两个条件显然都满足。接下来的运行过程，大家可以自己动手在纸上画一画，有助于自己理解划分过程。 i=0, j=1 123456 p,i j r 0 1 2 3 4 5 6 7| 2 | 8 | 7 | 1 | 3 | 5 | 6 | 4 |&lt;= x|i = 0, j = 1, x = 4A[j] = 8 &gt; 4 i=0, j=2 123456 p,i j r 0 1 2 3 4 5 6 7 | 2 | 8 | 7 | 1 | 3 | 5 | 6 | 4 | &lt;= x| &gt;x|i = 0, j = 2, x = 4A[j] = 7 &gt; 4 i=0, j=3 12345678 p,i j r 0 1 2 3 4 5 6 7 | 2 | 8 | 7 | 1 | 3 | 5 | 6 | 4 | &lt;= x| &gt;x |i = 0, j = 3, x = 4A[j] = 1 &lt; 4i = i + 1 = 0 + 1 = 1swap A[i] with A[j] &lt;===&gt; swap A[1] with A[3] i=1, j=4 12345678 p i j r 0 1 2 3 4 5 6 7 | 2 | 3 | 7 | 8 | 3 | 5 | 6 | 4 | &lt;= x | &gt; x |i = 1, j = 4, x = 4A[j] = 3 &lt; 4i = i + 1 = 1 + 1 = 2swap A[i] with A[j] &lt;===&gt; swap A[2] with A[4] i=2, j=5 123456 p i j r 0 1 2 3 4 5 6 7 | 2 | 3 | 3 | 8 | 7 | 5 | 6 | 4 | &lt;= x | &gt; x |i = 2, j = 5, x = 4A[j] = 5 &gt; 4 i=2, j=6 123456 p i j r 0 1 2 3 4 5 6 7 | 2 | 3 | 3 | 8 | 7 | 5 | 6 | 4 | &lt;= x | &gt; x |i = 2, j = 6, x = 4A[j] = 6 &gt; 4 i=2, j=7 12345 p i r,j 0 1 2 3 4 5 6 7 | 2 | 3 | 3 | 8 | 7 | 5 | 6 | 4 | &lt;= x | &gt; x | =x|循环结束 从上述过程可以看出，在每一轮迭代的开始，该循环不变量始终是满足的。 最后，swap A[i+1] with A[r]12345 p i q r,j 0 1 2 3 4 5 6 7 | 2 | 3 | 3 | 4 | 7 | 5 | 6 | 8 | &lt;= x | =x| &gt; x结束一次划分 2. 变体实现实际上也可以不选x=A[r]作为主元。 2. 1. x=A[p]作为主元可以选择x=A[p]作为主元，相应的循环不变量要进行适当调整： 若p+1 &lt;= k &lt;= i，则A[k] &lt;= x 若i+1 &lt;= k &lt;= j-1，则A[k] &gt; x 若x == p，则A[k] == x 若j &lt;= k &lt;=r，对应位置的值与主元之间不存在特定的大小关系 仍以上面的样例数组为例进行一次划分操作，当划分的迭代结束时，有：1234 p i r j 0 1 2 3 4 5 6 7| 2 | 1 | 7 | 8 | 3 | 5 | 6 | 4 | &lt;= x | &gt; x 此时，不再是进行swap A[i+1] with A[r]，由于主元x=A[p]位于数组的最左端，主元位置应该换进的是小于等于x的元素，所以便是进行swap A[i] with A[p]操作，这样交换后：1234 p i r j 0 1 2 3 4 5 6 7| 1 | 2 | 7 | 8 | 3 | 5 | 6 | 4 |&lt;= x| =x| &gt; x 下标i就是要找的切分点。 2. 2. 选择数组中的任意某个元素x=A[u]作为主元这里我们假设u != p同时u != r，除此之外对u的取值没有限制。基于此，我们的循环不变量可以调整为： 若p &lt;= k &lt;= i同时k != u，则A[k] &lt;= x 若i+1 &lt;= k &lt;= j-1同时k != u，则A[k] &gt; x 若k == u，则A[k] == x 若j &lt;= k &lt;= r同时k != u，对应位置的值与主元之间不存在特定的大小关系 只是这样的话，当划分操作的迭代过程经过位于p+1和r-1之间的主元时，需要进行特殊的加1操作跳过主元，并在迭代完成后依据主元与最终i所处的位置大小关系来决定如何进行交换操作，这样就加大了算法本身的复杂性，所以一般不采取这样的方法。 但是从以上的分析可以，对于主元x的选取是任意的，只是相应的循环不变量有所不同，以及算法本身的复杂性可能不同。为了避免主元出现在数组的中部，造成迭代过程额外的要跳过主元的复杂性，一般选择尾元素x=A[r]或头元素x=A[p]作为主元。 3. 三路划分算法随着我们对快排的熟悉，我们会发现目前的算法对于有大量重复元素或者元素完全相同的数组时，会退化为一个$O(n^2)$的算法。究其原因，是因为快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素。如果划分平衡，那么快速排序算法性能与归并排序一样了，是$O(nlgn)$的复杂度；如果划分不平衡，那么快速排序的性能就接近于插入排序了，是$O(n^2)$的复杂度。那数组元素完全一样的极端情况，此时的划分过程会将全部元素归到小于等于主元x的区域，不存在大于x的区域。因此每次解决步骤递归调用快排算法时，一边数组规模只是比上一次减1，另一边数组规模为0，所以就退化为一个每次减1的递归调用，而划分过程需要遍历整个子数组，即$T(n)=T(n-1) + O(n)$，容易得到$T(n) = O(n^2)$。为此我们可以考虑将划分进一步细化：划分操作将数组元素有原来的两类增加为三类：小于主元的，等于主元的，以及大于主元的，划分完成后只对小于主元和大于主元的两部分进行递归。这就是三路划分的思想，我们选择x=A[r]作为主元，则此时的循环不变量为： 若p &lt;= k &lt;= i，则A[k] &lt; x 若i+1 &lt;= k &lt;= e，则A[k] == x 若e+1 &lt;= k &lt;= j-1，则A[k] &gt; x 若k == r，则A[k] == x 若j &lt;= k &lt; r，对应位置的值与主元之间不存在特定的大小关系 基于该循环不变量，我们的算法改写为如下，仍为Python实现：123456789101112131415161718192021def partition3(A, p, r): i = p - 1 x = A[r] for j in range(p, r): # j:[p, r-1] if A[j] &lt; x: i += 1 A[i], A[j] = A[j], A[i] ''' 1. p &lt;= k &lt;= i, A[k] &lt; x 2. i+1 &lt;= k &lt;= r-1, A[k] &gt;= x 3. k == r, A[k] == x 继续处理A[i+1...r]之间大于等于x的元素 ''' e = i for j in range(i+1, r): # j:[i+1, r-1] if A[j] == x: e += 1 A[e], A[j] = A[j], A[e] e += 1 A[e], A[r] = A[r], A[e] return i, e+1 # A[p...i] &lt; x, A[e+1...r] &gt; x 如果理解了上面的算法，相信你也很容易理解该算法，无非就是迭代过程先将元素分为小于主元和大于等于主元的两部分，再对大于等于主元的部分进行细化，分为等于主元的和大于主元的两部分，这样就完成了三路划分的任务。 光说不练不行，我们来刷一道LeetCode的题目Sort List来检验下效果。题目要求： 要求对一单链表进行排序，时间复杂度限制在$O(nlgn)$，只能使用常量的地址空间。 参照三路划分思想我们可以解决这个问题，同时注意到是单链表，一开始我们无法拿到尾元素tail.val作为主元，所以我们选择首元素head.val作为主元。以下为我的代码实现，同样为Python：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ # 选择None作为链表的结尾哨兵 self.quickSort(head, None) # 返回排序后的头节点head return head def quickSort(self, head, tail): if head != tail\ and head.next != tail: # List is not None and List has not only one element pLt_next, pGt = self.partition3(head, tail) self.quickSort(head, pLt_next) self.quickSort(pGt, tail) def partition3(self, head, tail): pi = head x = head.val pj = head.next while pj != tail: if pj.val &lt; x: pi = pi.next #print('pi, pj: %d %d' % (pi.val, pj.val)) pi.val, pj.val = pj.val, pi.val pj = pj.next ''' head.next -&gt; ... -&gt; pi, node.val &lt; x pi.next -&gt; ... -&gt; pj, node.val &gt; x ''' pe = pi pj = pi.next while pj != tail: if pj.val == x: pe = pe.next pe.val, pj.val = pj.val, pe.val pj = pj.next ''' head.val == x head.next -&gt; ... -&gt; pi, node.val &lt; x pi.next -&gt; ... -&gt; pe, nonde.val == x pe.next -&gt; ... -&gt; tail.prev, node.val &gt; x swap head.val with pi.val ''' #print('head, pi: %d %d' % (head.val, pi.val)) head.val, pi.val = pi.val, head.val ''' head -&gt; ... -&gt; pi.prev, node.val &lt; x pi -&gt; ... -&gt; pe, node.val == x pe.next -&gt; ... -&gt; tail.prev, node.val &gt; x ''' return pi, pe.next 调试了一些引用错误后，顺利AC了! 4. 参考文章 【算法杂谈 1】 从一道面试题再看三路快排partition 算法导论 原书第三版 第7章 快速排序 Github CLRS/Chapter_07_Quicksort/exercises_7.1.md#7.1-2]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>排序</category>
        <category>快速排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>快速排序</tag>
        <tag>三路快排划分</tag>
        <tag>循环不变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim配置及插件安装自动化脚本]]></title>
    <url>%2Fposts%2F8f8a9ec7%2F</url>
    <content type="text"><![CDATA[1. 简介半年之前，我大概花了一周的时间折腾Ubuntu环境下的Vim，可能有人还不清楚，Ubuntu自带的vimvi，是vim的tiny版本，之所以预装这个tiny版本，是因为它足够小，而且能够满足一般的编辑需求，但是该tiny版本不能使用小键盘和方向键，这就造成了一个令人发狂的问题：在编辑模式下，移动光标会变成A B C D等字符并换行，而不是原来的上下左右移动，相信这个问题会让许多人和我一样困扰！所以配置Vim的过程踩了许多坑，第一个就是卸载这个tiny版本的vim，安装完整的vim，之后是在自己的HOME目录建立自己的配置文件.vimrc，以及添加显示行号，语法高亮等基本配置，再到后面知道可以用Vundle插件管理工具安装各种插件，用Vim打造出类似IDE的开发环境……，不断往.vimrc中添加各种配置，折腾起来就是大半天，而且换台机器，还得重新来一次，简直是累觉不爱。最近在看shell编程，就萌生出写一个自动化脚本，完成在一个新的Ubuntu系统的机器上Vim的配置及插件安装工作，经过几天的努力，终于这个小脚本诞生了！ 适用环境 脚本地址 Ubuntu https://github.com/Wangzhike/VimConfigScript 注：表格上的适用环境都已经过验证！ 无图无真相，最终的效果见下图： 2. 安装2. 1. 克隆脚本1git clone https://github.com/Wangzhike/VimConfigScript.git 2. 2. 安装脚本目前脚本自动安装的插件有： 自动补全插件YouCompleteMe 语法检查插件syntastic 代码折叠插件SimpylFold 显示文件树/文件目录插件NERDTree 状态栏增强插件vim-airline 查看显示代码文件中的宏，函数，变量定义等的插件taglist 安装： 进入脚本所在目录 1$ cd VimConfigScript 执行脚本configVim.sh目前脚本支持三种命令行参数： ./configVim.sh -all或./configVim.sh会安装上面提到的所有插件 ./configVim.sh -s [Plugin1] [Plugin2] ... [PluginN]会安装-s后面指定的插件，插件名字之间以空格分隔 ./configVim.sh -v [Plugin1] [Plugin2] ... [PluginN]除了-v后面指定的插件外，安装上面提到的所有插件 注：插件名称列表如下： YouCompleteMe Syntasitic SimplyFold NERDTree AirLine Taglist Taglist举例： 只安装Syntastic SimplyFold Taglist插件 1$ ./configVim.sh -s Syntastic SimpylFold Taglist 安装除了YouCompleteMe以外的所有插件 1$ ./configVim.sh -v YouCompleteMe 欢迎各位适用以及改进，如有问题可以评论留言，一直努力打造更好用的Vim环境。]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>Shell</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量]]></title>
    <url>%2Fposts%2F13ffbe88%2F</url>
    <content type="text"><![CDATA[1. 变量的显示与设置 设置变量和Python等脚本语言一样，在shell里，使用变量之前并不需要事先为它们做出声明，只是通过使用它们(比如当你给它们赋初始值时)来创建它们。 1$ VARIABLE_NAME=value 显示变量的内容通过在变量名前加一个$符号来访问它的内容。一种检查变量内容的简单方式就是在变量名前加一个$符号，再用echo命令将它的内容输出到终端上。 12$ echo $变量名$ echo $&#123;变量名&#125; 取消变量 1$ unset 变量名 2. 变量的约定 引号的使用变量之间以空白字符(例如，一个空格，一个制表符或者一个换行符)分隔，如果变量内容包含一个或多个空白字符，必须给变量加上引号。像$foo这样的变量在引号中的行为取决于你所使用的引号类型。 双引号把$变量表达式放在双引号中，程序执行到这一行时会把变量替换为它的值，如var=&quot;long is $LONG&quot;，则echo $var可得long is en_US。 单引号把$变量表达式放在单引号中，不会发生替换现象，如var=&#39;long is $LONG&#39;，则echo $ar可得long is $LONG。还可以在$字符前面加上一个\字符取消它的特殊含义。 所以字符串通常都放在双引号中，以防止变量被空白字符分开，同时又允许$扩展。 为了增加一个变量的内容时，则可用$变量名或${变量名}累加内容，如下所示： 1$ PATH=$PATH:/home/bin `…`或$(...)获取子进程输出在一串命令中，还需要使用通过其他命令提供的信息，可以使用反引号`命令`或$(命令)。在一串命令内，在``之内或$()之内的命令将会被先执行，而执行的结果将作为外部的输入信息。 12$ echo `uname -r`4.4.0-66-generic 3. 环境变量当一个shell脚本开始执行时，一些变量会根据环境设置中的值进行初始化，这些变量称为环境变量。环境变量通常用大写字母做名字，而用户在脚本程序里定义的变量通常用小写字母做名字。 下面列出了一些主要的环境变量 HOME当前用户的家目录。 PATH以冒号分隔的用来搜索命令的目录列表。系统通过PATH这个变量里面的内容所记录的路径来查找某个需要执行的命令。所以你能不能在任何目录下执行某个命令与PATH这个变量有很大的关系。如果在找完PATH变量内的路径还找不到ls这个命令时，就会在屏幕上显示&quot;commond not found&quot;的错误信息。 $0shell脚本的名字 $$shell脚本的PID(进程号)。脚本程序通常会用它来生成一个唯一的临时文件，如/tmp/tmpfile_$$。 3. 1. 显示环境变量 env是environment(环境)的简写，功能是列出所有的环境变量 set查看所有变量，包含环境变量和自定义变量 3. 2. 导出环境变量3. 2. 1. 临时导出自定义变量3. 2. 1. 1. export 自定义变量export命令将作为它的参数的变量导出到子shell中，并使之在子shell中有效。子进程会继承父进程的环境变量，但不会继承父进程的自定义变量。也就是说，在一个shell中被创建的变量在这个shell调用的下级(子)shell中是不可用的。执行export 变量名可以让这些自定义变量在子进程中使用。但只在当前父进程及其子进程有用，当父子进程全部退出，该自定义变量也不再保留。 我们用下面两个脚本export1和export2来说明它的用法。 先列出脚本程序export2 1234#!/bin/shecho "$foo"echo "$bar" 然后是脚本export1。在这个脚本的结尾，我们调用了export2。 123456#!/bin/shfoo="The first meta-syntactic variable"export bar="The second meta-syntactic variable"export2 运行这个脚本程序，你将得到如下的输出：123$ ./export1The second meta-syntactic variable 解析：export2脚本只是回显两个变量的值。export1脚本同时设置两个变量的值，但只导出变量bar，所以当它其后调用export2时，变量foo的值已丢失，但变量bar的值已被导出到第二个脚本中。脚本输出中的第一个空行的出现是因为$foo在export2中没有定义，回显一个null变量将输出一个空行。 3. 2. 1. 2. source 自定义环境变量3. 2. 1. 2. 1. 在脚本中 export 自定义的环境变量如果在shell脚本中export环境变量，执行完脚本后，查看该环境变量竟然看不到。 为什么在shell脚本里用export环境变量之后，当shell执行完了，用set命令看不到呢？但是如果直接在终端里export环境变量用set是可以看到的？ 这里的关键在于理解shell脚本的执行方法。当执行一个shell脚本时，是在当前终端所在的shell fork出一个子shell执行该脚本，执行完毕再返回终端所在的shell。因此在脚本中设置了环境变量，它只在fork出来的子shell以及该子shell的子shell，也就是子shell和子子shell中生效，子shell只能继承父shell的环境变量，而不能修改父shell的环境变量，所以子shell执行结束，父shell的环境变量没有改变，看不到脚本中设置的环境变量的值。 3. 2. 1. 2. 2. 解决办法那么如何让脚本的环境变量在脚本执行之后仍然对当前终端存在呢？用source或.(dot)。明确告诉shell不要fork执行脚本，而是在当前的shell执行，这样环境变量就可以保存下来了。 source 命令用法： 12$ source filename # (source 通常用.来代替)$ source test.sh # 与 . test.sh 是相同的 3. 2. 2. 永久导入自定义变量HOME目录下的.profile文件用来保存当前用户设置的环境变量。通过编辑.profile文件，在里面通过export语句导入自定义的变量，可以永久导入该自定义的变量。 1$ export MAIL_USERNAME="15091521590@163.com" 该语句永久导入用户自定义的MAIL_USERNAME变量。]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的模块与包]]></title>
    <url>%2Fposts%2F125cf81d%2F</url>
    <content type="text"><![CDATA[1. 模块1. 1. 什么是模块在Python中，一个.py文件就是一个模块，一般情况下，模块的名字就是文件名，但是不带.py后缀。举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。模块的名字保存在全局变量__name__中。模块可以被导入到其他模块，也可以被导入到主模块(main module)。主模块是脚本在顶层或计算器模式下执行时你能访问的所有变量的集合，也就是说当该模块作为脚本执行时它就是被导入到主模块。前面提到，一般情况下，模块的名字就是文件名，而当模块作为脚本执行时，就是特殊情况。当模块作为脚本执行时，__name__被设置为__main__。__main__是顶层代码执行作用域的名字。通过判断__name__的值，我们可以知道模块是否正在被当做脚本执行，同样也可以选择性地执行某些代码：123if __name__ == '__main__': # execute only if run as a script # you code is here 1. 2. 模块的命名空间模块化组织代码有很多好处，实现功能分割与解耦，提高代码的可维护性。其次，模块的代码可以在其他地方引用等等。其中很重要的一点就是可以避免函数名和变量名冲突。每一个模块有自己的私有符号表，保存在模块自己的命名空间中(此处为个人总结，可能有错误！)。对于模块内部的函数而言，这个私有符号表就是全局符号表，因此可以自由访问模块中定义的变量。同时不同模块各自拥有独立的私有符号表，这就使不同模块的作者不用担心自己模块中使用的变量名会和其他作者模块中的变量名冲突。 1. 3. 导入模块1. 3. 1. 导入模块的两种方式Python提供了至少两种方式导入一个模块。 import X导入模块X，并且以X的命名空间为名字将X中定义的变量导入到当前的命名空间。换而言之，在你执行这个语句之后，你能用X.name引用模块X中定义的对应变量。 from X import *导入模块X，并且直接以X中定义的变量名为名字将X中定义的公有变量(名字不是以下划线_开头的变量)导入到当前的命名空间。换而言之，当你执行玩这个语句之后，你可以直接使用变量名，而不用加X.前缀来引用模块X中定义的对应变量。但是模块名X本身没有被定义，所以X.name这样形式的语句是错误的。同时，如果在此之后改变了模块X中某些变量的定义，在当前的命名空间中不会进行更新。注意import *是一种不建议使用的写法，因为它引入的变量名可能会与当前命名空间中之前已经定义过的变量名同名，产生命名冲突，从而覆盖掉之前同名变量的定义，这是一个让人很难检查出的问题。在交互式环境，如IPython，Python自带的shell等环境下，可以使用这种写法。 from X import a, b, c这个其实仍然属于第二种方式，导入模块X，并且直接以X中定义的变量名为名字将X中给定的公有变量导入到当前的命名空间。换而言之，你可以在程序中使用a，b，c这三个变量。 1. 3. 2. 导入模块的内部机制当Python导入一个模块时，它首先在模块注册表(sys.modules)中检查是否有该模块，如果有则直接从已经存在的模块对象的命名空间中按照对应的import语句导入变量。如果该模块不存在，它的执行流程如下： 创建一个新的空的模块对象，此时该模块的命名空间为空 将该模块对象插入到sys.modules字典 加载该模块代码，必要时先变异该模块 在该模块的命名空间下执行模块中的代码，代码中所有被定义的变量(包括变量，函数，类)都将被添加到模块的命名空间里 也就是说，当模块第一次被正在执行的脚本导入时，Python会转而执行该模块中的代码来初始化该模块的命名空间。当其他模块第二次导入该模块时，由于该模块已经存在于模块注册表sys.modules中，它将不会被再次加载，所以模块中定义的变量仅仅被初始化了一次。 1. 3. 3. 循环导入(Cirular Imports)当执行import语句导入模块时，程序将转而执行该模块中的代码，而模块中定义的变量，比如def，class还不存在于模块的命名空间直到执行到def或class对应的定义语句，它们才会被添加到命名空间。考虑这样一种情况：在模块X中将导入模块Y，同时定义了一个名为spam的函数：12345# module Ximport Ydef spam(): print('function in module X') 如果在主程序中导入模块X，Python将加载X的代码并执行它。当遇到import Y语句时，它将加载模块Y的代码并跳转到Y执行。此时，Python已经将X和Y添加到了模块注册表sys.modules中，但是此时X的命名空间还为空，不包含任何变量，而import Y之后紧跟的def spam函数定义也没有执行。如果模块Y中又导入了X，就构成了循环导入，而循环导入极有可能产生错误。当模块Y又导入X时，它将首先检查sys.modules，此时X已经存在，所以它将引用X空的命名空间，因为X的命名空间为空，所以此时任何尝试访问X.spam的语句，都将产生错误。12# module Yfrom X import spam # doesn't work: spam isn't defined yet! 同样下面的代码也会遇到错误：1234# module Yimport XX.spam() # doesn't work either: spam isn't defined yet! 要解决这个错误，有两种方法： 将模块X和Y中都要引用的变量定义移动到一个独立的文件中，X和Y都从这个文件中引用需要的变量 将import语句移动到模块的结尾如果将模块X中的import Y语句移动到结尾，可以解决这个问题。 1. 3. 4. 模块的搜索路径当导入一个名为spam的模块时，Python的搜索顺序如下： 在内置模块(bulit-in module)查找对应的模块名 未命中，则在sys.path列表给出的目录列表中查找名为spam.py的文件而sys.path以下面的先后顺序进行初始化： 添加输入脚本所在的目录(如果没有指定脚本则为当前目录) 添加系统变量PYTHONPATH指定的目录列表，PYTHONPATH类似与shell变量PATH 添加Python的安装路径的目录 注意，在初始化sys.path之后，Python会修改sys.path，将执行脚本所在的目录放在搜索列表的最前面，位于标准库目录的前面。这就意味着当脚本所在目录存在和标准库模块同名的模块时，Python将加载脚本所在目录的模块而不是标准库中的模块，这也是一个常见的不好排查的错误。为了避免自己定义的模块与标准库冲突，从而需要引入包的概念。 2. 包2. 1. 什么是包包是一种通过”dotted module names”的引用方式来构造模块命名空间的方法。Python中的包是一个目录但必须包含一个特殊的名为__init__.py的文件，最简单的该文件可以为空，也可以包含该模块的初始化代码或设置__all__变量的值。该文件表明该目录是一个可导入的包，而不是一个普通目录。就像，模块名A.B在一个名为A的包中指定了一个名为B的子模块。通过引入模块，使不同模块的作者不用担心彼此模块中的全局变量名产生冲突。类似的，引入包采用”dotted module names”的方式使不同的多模块包的作者不用担心彼此模块名产生冲突。 2. 2. 导入包2. 2. 1. 导入包的不同形式 from package import itemitem可以是一个子模块或子包，也可以是package中定义的函数，类或变量。该语句首先检查item是不是package中定义的变量(package所在目录下的init.py文件中是否有item变量的定义)，如果不是，则假设item是一个模块，并尝试加载它，如果失败，会抛出ImportError异常。 import item.subitem.subsubitem除了最后一个subsubitem，其余的所有的item,subitem都必须是一个包，最后一个subsubitem可以是一个模块或者包，但不能是subitem中定义的函数，类或变量。 from package import *如果__init__.py中定义了一个列表变量__all__，将导入与__all__中包含的所有字符串同名的那些模块。如果__init__.py中没有定义__all__，并不会像from module import *会导入模块中所有公有变量到当前命名空间那样，导入包中含有的所有子模块到当前命名空间。而是仅确保该包名被导入，同时如果__init__.py不为空还执行其中的代码，这样就又会导入__init__.py文件中定义的所有名字，包括其中通过import语句导入的模块名。比如下面的例子：包的结构如下：12345678910|- A/ |- __init__.py |- a.py |- b.py |- c.py |- B/ |- __init__.py |- a.py |- b.py |- c.py 在A/所在目录下进入交互式环境，执行from B import *代码，而A/B/__init__.py内容如下：123print('Subpackage B init.')import afrom B import b 输出如下：1Subpackage B init. 继续执行：123456&gt;&gt;&gt; B&lt;module 'B' from '/home/qiuyu/code/Web/moduleNameSpace/A/B/__init__.py'&gt;&gt;&gt;&gt; B.a&lt;module 'a' from '/home/qiuyu/code/Web/moduleNameSpace/A/a.py'&gt;&gt;&gt;&gt; B.b&lt;module 'B.b' from '/home/qiuyu/code/Web/moduleNameSpace/A/B/b.py'&gt; 由于是从A/所在目录进入交互式环境的，所以sys.path搜索目录列表的第一项是A/所在的目录，所以import a导入的是A/目录下的a.py模块，而from B import b首先检查到b不是包B中定义的变量，所以假设b是一个模块而尝试导入它，这样就导入了A/B/b.py模块。 2. 2. 2. 包内引用/相对导入当一个包中含有子包时，你可以通过在当前包中通过绝对导入引入兄弟包中的模块，也可以通过相对导入来引入模块。相对导入使用”leading dots”来指示当前包和父包。“.”表示当前包所在目录，”..”表示父包所在目录。所以上面的from B import b也可以改写为from .B import b。注意，**相对导入依赖于当前模块的名字。当该模块作为主模块导入时，其__name__的值为__main__，而__main__没有提供模块的真实名字，不能使用相对导入。也就是说，当一个模块作为主模块使用时，只能使用绝对导入。 3. 参考文献 Importing Python Modules Modules and Packages - Learn Python - Free Interactive Python Tutorial 模块 - 廖雪峰的官方网站 6. Modules — Python 3.6.2 documentation 29.4. main — Top-level script environment — Python 3.6.2 documentation]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
        <category>语法基础</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>Package</tag>
        <tag>Import</tag>
        <tag>Cirular Imports</tag>
        <tag>Relative Imports</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
</search>