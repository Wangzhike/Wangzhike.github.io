<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋雨的网络日志</title>
  
  <subtitle>自律给我自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangzhike.github.io/"/>
  <updated>2020-10-18T15:44:14.925Z</updated>
  <id>https://wangzhike.github.io/</id>
  
  <author>
    <name>秋雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>brpc初探</title>
    <link href="https://wangzhike.github.io/2020/08/29/introduct_to_brpc_tmp/"/>
    <id>https://wangzhike.github.io/2020/08/29/introduct_to_brpc_tmp/</id>
    <published>2020-08-29T10:51:07.000Z</published>
    <updated>2020-10-18T15:44:14.925Z</updated>
    
    <content type="html"><![CDATA[<p>最近组里准备把我们的在线召回服务由proxygen http迁移到brpc调用，我负责调研下brpc相关内容。虽然早已久仰brpc的大名，但并没有特意了解过。本文以brpc提供的<code>echo_c++</code>例程入手学习，算是初探brpc的文字记录。</p><a id="more"></a><h1 id="1-protobuf-service"><a href="#1-protobuf-service" class="headerlink" title="1. protobuf service"></a>1. protobuf service</h1><p>brpc基于<a href="https://developers.google.com/protocol-buffers/docs/overview#services" target="_blank" rel="noopener">protobuf service</a>的RPC接口实现RPC服务。<br>RPC的请求（request）和回复（response）定义为protobuf的message，RPC服务的接口都由protobuf的service定义。protobuf编译器protoc根据protobuf service中选择的语言（<code>option cc_generic_services = true</code>）生成rpc服务的接口和stub存根。下面以<code>service EchoService</code>为例进行说明。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">"proto2"</span>;</span><br><span class="line"><span class="keyword">package</span> echo;</span><br><span class="line"></span><br><span class="line"># 告诉protoc要生成C++ Service基类，如果是java或python，则应分别修改为java_generic_services和py_generic_services</span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EchoRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">message</span> EchoResponse </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">service</span> EchoService </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Echo (EchoRequest) <span class="keyword">returns</span> (EchoResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-接口Interface"><a href="#1-1-接口Interface" class="headerlink" title="1.1 接口Interface"></a>1.1 接口Interface</h2><p>使用protoc编译这个<code>.proto</code>，将生成同名的<code>EchoService</code>类表示这个RPC服务。对service中定义的每个rpc方法（如<code>rpc Echo (EchoRequest) returns (EchoResponse)</code>），生成的<code>EchoService</code>类中都由一个对应的同名虚函数（如<code>Echo</code>）。<br>这些生成的方法是虚函数，但不是纯虚函数。默认实现只是调用<code>controller-&gt;SetFailed()</code>并带有一条错误信息，指出该方法未实现，然后调用<code>done</code>回调。在实现自己的服务时，你必须子类化（subclass）生成的服务并适当实现它的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoService</span> :</span> <span class="keyword">public</span> ::google::protobuf::Service &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// This class should be treated as an abstract interface.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">EchoService</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~EchoService();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> EchoService_Stub Stub;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ::google::<span class="function">protobuf::ServiceDescriptor* <span class="title">descriptor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Echo</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> ::echo::EchoRequest* request,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ::echo::EchoResponse* response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ::google::protobuf::Closure* done)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// implements Service ----------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ::google::<span class="function">protobuf::ServiceDescriptor* <span class="title">GetDescriptor</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CallMethod</span><span class="params">(<span class="keyword">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ::google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ::google::protobuf::Closure* done)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> ::google::<span class="function">protobuf::Message&amp; <span class="title">GetRequestPrototype</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> ::google::protobuf::MethodDescriptor* method)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">const</span> ::google::<span class="function">protobuf::Message&amp; <span class="title">GetResponsePrototype</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> ::google::protobuf::MethodDescriptor* method)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EchoService);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-存根Stub"><a href="#1-2-存根Stub" class="headerlink" title="1.2 存根Stub"></a>1.2 存根Stub</h2><p>protoc也为中每个服务接口生成了一个Stub实现，客户端使用该Stub实现向实现了该service的服务器发送请求。对于上面的<code>service EchoService</code>，Stub实现被定义为<code>class EchoService_Stub</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoService_Stub</span> :</span> <span class="keyword">public</span> EchoService &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  EchoService_Stub(::google::protobuf::RpcChannel* channel);</span><br><span class="line">  EchoService_Stub(::google::protobuf::RpcChannel* channel,</span><br><span class="line">                   ::google::protobuf::Service::ChannelOwnership ownership);</span><br><span class="line">  ~EchoService_Stub();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">inline</span> ::google::<span class="function">protobuf::RpcChannel* <span class="title">channel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> channel_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// implements EchoService ------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> ::echo::EchoRequest* request,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ::echo::EchoResponse* response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ::google::protobuf::Closure* done)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ::google::protobuf::RpcChannel* channel_;</span><br><span class="line">  <span class="keyword">bool</span> owns_channel_;</span><br><span class="line">  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EchoService_Stub);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Stub已将protobuf service中的每个方法实现为围绕channel（around the channel）的一个wrapper。调用Stub的其中一个方法就是简单地调用<code>channel-&gt;CallMethod()</code>。Stub将所有调用转发到<code>RpcChannel</code>，其又是一个抽象接口，你必须根据自己的RPC系统具体实现。换而言之，生成的Stub提供了一个类型安全的接口，用于进行基于protobuf的RPC调用，而无需将你锁定到任何特定的RPC实现中。</p><p>Stub实现是生成的service类的子类，而server在实现自己的rpc服务时，也必须子类化生成的service类。也就是说rpc的client实现（class EchoService_Stub）以及rpc server实现（class EchoService的子类）都是生成的类（class EchoService）的子类。<br>综上，<code>class EchoService</code>由server继承实现，是rpc对应的实现。<code>class EchoServcie_Stub</code>由client调用，向实现了<code>class EchoService</code>的server发送请求。protobuf service不包括RPC的实现。但是，它包含了将生成的service类（EchoService接口、EchoServer_Stub类）连接到你选择的任意RPC实现所需的所有工具。我们只需要提供<code>RpcChannel</code>和<code>RpcController</code>的实现。</p><h1 id="2-client"><a href="#2-client" class="headerlink" title="2. client"></a>2. client</h1><p>如前所述，pb service不包括RPC的实现。但是，它包含了将生成的service类（EchoService接口、EchoServer_Stub类）连接到你选择的任意RPC实现所需的所有工具。我们只需要提供<code>RpcChannel</code>和<code>RpcController</code>的实现。但是如果client要实现异步访问，我们还需要提供<code>Closure</code>的实现。<br>我们来看下rpc client中<code>RpcChannel</code>和<code>RpcController</code>的实现，以及<code>Closure</code>的用法。</p><h2 id="2-1-brpc-Channel"><a href="#2-1-brpc-Channel" class="headerlink" title="2.1 brpc::Channel"></a>2.1 <code>brpc::Channel</code></h2><p><code>brpc::Channel</code>代表了与一台或多台服务器的交互通道（communication line）。</p><h2 id="2-2-brpc-Controller"><a href="#2-2-brpc-Controller" class="headerlink" title="2.2 brpc::Controller"></a>2.2 <code>brpc::Controller</code></h2><p><code>brpc::Controller</code>调解（mediates）单个方法调用。controller的主要目的是提供一种方法来操纵（manipulate）每个RPC调用的设置，并找出有关RPC级别的错误。</p><h2 id="2-3-google-protobuf-closure"><a href="#2-3-google-protobuf-closure" class="headerlink" title="2.3 google::protobuf::closure"></a>2.3 <code>google::protobuf::closure</code></h2><p><code>google::protobuf::closure</code>是回调的抽象接口。异步调用RPC时，必须提供一个闭包（closure）以便在过程（procedure）完成时调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LIBPROTOBUF_EXPORT</span> <span class="title">Closure</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Closure() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~Closure();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Closure);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于<code>google::protobuf::closure::Run()</code>是纯虚函数，因此可以将继承并实现该接口的子类对象可以作为异步访问时的回调对象。更简单的，是使用<code>NewCallback()</code>函数，自动构造一个使用一组特定参数来调用特定函数或方法的闭包。</p><h3 id="2-3-1-google-protobuf-NewCallback"><a href="#2-3-1-google-protobuf-NewCallback" class="headerlink" title="2.3.1 google::protobuf::NewCallback()"></a>2.3.1 <code>google::protobuf::NewCallback()</code></h3><p>目前<code>goole::protobuf::NewCallback()</code>函数支持绑定零、一或两个参数。使用<code>NewCallback()</code>创建的回调在执行时会自动删除。<code>NewCallback()</code>创建的回调仅且只能被调用一次（is to be called exactly once），其通常是用于RPC回调。<br>需要注意，<code>NewCallback()</code>对于参数类型比较敏感。通常，为参数绑定提供的值必须与回调函数接受的类型完全匹配（exactly match）。并且，参数不能是引用。但是，正确类型的指针可以正常工作。</p><h3 id="2-3-2-brpc-NewCallback"><a href="#2-3-2-brpc-NewCallback" class="headerlink" title="2.3.2 brpc::NewCallback()"></a>2.3.2 <code>brpc::NewCallback()</code></h3><p>由于protobuf 3把NewCallback设置为私有，r32035后brpc把NewCallback独立于<code>src/brpc/callback.h</code>并增加了一些重载。<code>brpc::NewCallback()</code>最多支持10个参数，类型要求同<code>google::protobuf::NewCallback()</code>。</p><h1 id="3-server"><a href="#3-server" class="headerlink" title="3. server"></a>3. server</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近组里准备把我们的在线召回服务由proxygen http迁移到brpc调用，我负责调研下brpc相关内容。虽然早已久仰brpc的大名，但并没有特意了解过。本文以brpc提供的&lt;code&gt;echo_c++&lt;/code&gt;例程入手学习，算是初探brpc的文字记录。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>右值引用</title>
    <link href="https://wangzhike.github.io/2020/08/23/rvalue_reference/"/>
    <id>https://wangzhike.github.io/2020/08/23/rvalue_reference/</id>
    <published>2020-08-23T12:27:07.000Z</published>
    <updated>2020-10-18T15:44:14.925Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考<a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">C++ Rvalue References Explained</a>和C++ Primer第五版。</p><p>右值引用主要用于解决两个问题：</p><ol><li>实现移动语义</li><li>完美转发<a id="more"></a></li></ol><h2 id="1-左值与右值"><a href="#1-左值与右值" class="headerlink" title="1. 左值与右值"></a>1. 左值与右值</h2><p>简单而言，左值（lvalue）是一个表示（refers to）存储位置的表达式，它允许我们通过<code>&amp;</code>运算符获取该存储位置的地址。右值（rvalue）则是不是左值的表达式。因此，左值有持久的状态，而右值要么是字面值常量，要么是在表达式求值过程中创建的临时对象，临时对象的状态是短暂的。<br>左值引用（lvalue reference）用于绑定到一个左值上，通过<code>&amp;</code>来声明左值引用。常量左值引用也可以绑定到一个右值上。右值引用（rvalue reference）必须绑定到右值上，除了字面值常量外，该右值是一个将要销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。不能将一个右值引用直接绑定到一个左值上，通过<code>&amp;&amp;</code>来声明右值引用。</p><h2 id="2-实现移动语义"><a href="#2-实现移动语义" class="headerlink" title="2. 实现移动语义"></a>2. 实现移动语义</h2><p>要实现移动语义，首先对象所属的类必须定义自己的移动构造函数和移动赋值运算符。对于<code>Class X</code>而言，移动构造函数和移动赋值运算符的接口为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X(X &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X&amp; <span class="keyword">operator</span>=(X &amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将移动构造函数和移动赋值运算符标记为<code>noexcept</code>，显示地告诉标准库我们的移动操作不会抛出异常，可以安全使用。这样在重新分配内存等适用移动语义的地方，标准库可以使用我们定义的移动操作而不是拷贝操作。<br>为了在普通函数和成员函数中实现移动语义，必须同时提供函数移动和拷贝两种版本。该函数使用和移动/拷贝构造函数和赋值运算符相同的参数模式——拷贝版本接受一个指向const的左值引用，移动版本接受一个指向非const的右值引用。以普通函数<code>foo</code>为例，两个版本的定义分别为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> X &amp;x)</span> </span>&#123;</span><br><span class="line">    X anotherX = x;     <span class="comment">// call X(X&amp; rths)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X &amp;&amp;x)</span> </span>&#123;</span><br><span class="line">    X anotherX = <span class="built_in">std</span>::<span class="built_in">move</span>(x);     <span class="comment">// call X(X &amp;&amp;x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，我们不需要为<code>foo</code>函数定义接受一个<code>const X&amp;&amp;</code>或是一个（普通的）<code>X&amp;</code>参数的版本。当我们希望从实参“窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受一个（普通的）<code>X&amp;</code>参数的版本。</p><p>我们注意到，<code>foo(X &amp;&amp;x)</code>中在赋值时使用了<code>std::move(x)</code>而不是直接使用形参<code>x</code>。这是实现移动语义的第二个关键点。核心问题是<strong>被声明为右值引用的变量是右值吗？</strong><br>实际上，<strong>被声明为右值引用的变量可以是左值或右值。区分的标准是：如果有名字（name），则为左值。否则，则是右值。</strong><br>上面的例子中，第二个<code>foo</code>函数的<code>x</code>被声明为右值引用，并且有名字，因此<code>x</code>是一个左值，要实现移动语义，必须使用<code>std::move(x)</code>将其转换为一个右值。下面的例子声明了一个右值引用并且没有名字，因此是一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X&amp;&amp; <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">X x = bar();    <span class="comment">// calls X(X &amp;&amp;rhs) because the thing on the right side has no name</span></span><br></pre></td></tr></table></figure><p>该规则背后的出发点是：允许移动语义默认应用于具有名字的对象，如<code>X anotherX = x</code>，会造成危险的混乱并且容易出错。因为我们刚刚移动的<code>x</code>，在后续的代码中仍然可以访问。而C++要求，在移动操作之后，移后源对象必须保持有效的、可析构的状态，并且用户不能对其值进行任何假设。但是这里的<code>x</code>可能在后面的代码中被读取，并且用户会认为<code>x</code>应该保持原来的值，而这个要求也是合理和直观的。因此，规则的前一半就应该为“如果右值引用有名字，则它是一个左值”。<br>而如果右值引用没有名字，则代表它是一个临时对象，可以知道其马上要被销户并且该对象没有其他用户，这两个特性意味着：可以自由接管该对象的资源。因此，规则的另一半就应该为“如果右值引用没有名字，则它是一个右值”。而且，这后一半规则可以使我们可以<strong>根据自己的意愿以一种受控的方式在左值上强制移动语义（force move semantics on lvualues）。这就是<code>std::move</code>的工作机制。</strong><code>std::move</code>可以接受一个左值，返回绑定到该左值上的右值引用，因为该右值引用没有名字，所以它是一个右值。也就是说，<code>std::move</code>将其参数转换为右值，如果该参数不是右值的话。并且它是通过隐藏名字来实现的。</p><p><code>std::move</code>的内部实现可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;   <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure><p><code>std::move</code>的内部实现，基于这样一个规则：<strong>虽然不能将一个右值引用直接绑定到一个左值上，但可以显示地（通过<code>static_cast</code>）将一个左值转换为对应的右值引用类型。</strong>我们必须意识到，调用<code>std::move(x)</code>就意味着承诺：除了对<code>x</code>赋值和销毁它外，我们将不再使用它。在调用<code>std::move</code>之后，我们不能对移后源对象的值做任何假设。</p><h2 id="3-完美转发"><a href="#3-完美转发" class="headerlink" title="3. 完美转发"></a>3. 完美转发</h2><p>对于模板类型参数的函数参数，转发就是参数传递，将函数实参传递给函数内部的另外一个函数。完美转发指的是，其转发效果就像外部函数不存在，内部函数直接被调用一样。具体而言，完美转发是指一个函数需要将一个或多个实参连同类型不变地转发给其他函数，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。<br>要实现完美转发，函数参数不能是值传递，否则无法转发引用实参，因此函数参数必须是模板类型参数的引用类型。</p><h3 id="3-1-左值引用函数参数"><a href="#3-1-左值引用函数参数" class="headerlink" title="3.1 左值引用函数参数"></a>3.1 左值引用函数参数</h3><p>当一个函数参数是模板类型参数的左值引用时，只能传递给它一个左值。实参可以是<code>const</code>类型，也可以不是。如果实参是<code>const</code>的，则模板类型参数<code>T</code>将被推断为<code>const</code>类型。<br>如果一个函数参数的类型是<code>const T&amp;</code>，则可以传递给它任何类型的实参——一个对象（<code>const</code>或非<code>const</code>）、一个临时对象或是一个字面值常量。当函数参数本身是<code>const</code>时，<code>T</code>的类型推断的结果不会是一个<code>const</code>类型。<code>const</code>已经是函数参数类型的一部分；因此，它不会也是模板类型参数的一部分。</p><p>可见，当函数参数是模板参数类型的左值引用时，只能转发左值实参（<code>T&amp;</code>），或可以接受任何类型的实参（<code>const T&amp;</code>）但将阻塞右值实参的移动语义，不能实现完美转发。</p><h3 id="3-2-右值引用函数参数"><a href="#3-2-右值引用函数参数" class="headerlink" title="3.2 右值引用函数参数"></a>3.2 右值引用函数参数</h3><p>当一个函数参数是模板参数的右值引用时，正常的绑定规则告诉我们可以传递给它一个右值，此时类型推断过程类似于左值引用函数参数的推断过程，推断出的<code>T</code>的类型为该右值实参的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T &amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>);     <span class="comment">// 实参是一个int类型的右值；模板参数T是int</span></span><br></pre></td></tr></table></figure><p>除此之外，C++语言在正常绑定规则（向右值引用函数参数传递一个右值）之外定义了两个例外规则：</p><ol><li>第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值（如<code>i</code>）传递给函数的右值引用参数，且此右值引用指向模板参数类型（如<code>T&amp;&amp;</code>）时，虽然通常我们不能将一个右值引用绑定到一个左值上，但此时该绑定是合法的，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用<code>f3(i)</code>时，编译器推断<code>T</code>的类型为<code>int&amp;</code>，而非<code>int</code>。</li><li>T被推断为<code>int&amp;</code>意味着<code>f3</code>的函数参数是一个类型<code>int&amp;</code>的右值引用。通常，我们不能直接定义一个引用的引用（因为引用是对象的别名，必须指向一个对象），但是，通过类型别名或通过模板类型参数间接定义是合法的。如果我们间接创建了一个引用的引用，则这些引用形成了“引用折叠”。除了右值引用的右值引用会折叠成右值引用外，其他引用都会折叠为一个普通的左值引用类型。即，对于一个给定类型<code>X</code>：<ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>和<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code></li></ul></li></ol><p>这两个规则导致了两个重要结果：</p><ul><li>如果一个函数参数是一个指向模板类型参数的右值引用（如<code>T &amp;&amp;</code>），则它可以被绑定到一个左值；且</li><li>如果实参是一个左值，则推断出的模板类型参数将是一个左值引用，且函数参数将被实例化为一个左值引用参数（<code>T&amp;</code>）</li></ul><p>综上，函数参数是模板类型参数的右值引用类型时，可以传递给它任意类型的参数，而且可以保持参数的左值或右值属性，可以用于实现完美转发。</p><h3 id="3-3-std-forward-lt-Arg-gt-arg"><a href="#3-3-std-forward-lt-Arg-gt-arg" class="headerlink" title="3.3 std::forward&lt;Arg&gt;(arg)"></a>3.3 <code>std::forward&lt;Arg&gt;(arg)</code></h3><p>函数参数是模板类型参数的右值引用，可以接受任意类型的参数且保持参数的左值或右值属性。但正如<a href="#2-实现移动语义">2. 实现移动语义</a>提到的，被声明为右值引用的变量可以是左值或右值。而在参数转发中，右值引用变量是函数参数，是有名字的，所以是左值，即使传递给该右值引用参数的是一个右值实参。<br>为了实现右值引用参数为右值实参时的移动语义，同时保证右值引用参数为左值时无移动语义，显然不能直接使用<code>std::move</code>处理右值引用参数，为此引入了<code>std::forward&lt;Arg&gt;(arg)</code>。<code>std::forward</code>是一个类模板，必须通过显示模板实参来调用，<code>std::forward</code>返回该显示实参类型的右值引用。即，<code>std::forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。通常情况下，我们使用<code>std::forward</code>传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，<code>std::foward</code>可以保持给定实参的左值/右值属性。对于右值引用参数的左值实参可以返回一个左值类型，对于右值引用的右值实参则返回一个右值。其内部实现可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</span><br><span class="line"><span class="function">Arg&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;Arg&gt;::type&amp; arg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Arg&amp;&amp;&gt;(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure><p>实际上，<code>std::forward</code>中的<code>remove_reference</code>是不需要的，我们将<code>typename remove_reference&lt;Arg&gt;::type&amp;</code>替换为<code>Arg&amp;</code>也可以保证完美转发，但此时必须显示指明<code>Arg</code>为<code>std::forward</code>的模板类型参数。而<code>std::forward</code>中的<code>remove_reference</code>用于迫使我们必须这样做。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要参考&lt;a href=&quot;http://thbecker.net/articles/rvalue_references/section_01.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++ Rvalue References Explained&lt;/a&gt;和C++ Primer第五版。&lt;/p&gt;
&lt;p&gt;右值引用主要用于解决两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现移动语义&lt;/li&gt;
&lt;li&gt;完美转发&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>我在鹅厂的九个月</title>
    <link href="https://wangzhike.github.io/2020/03/08/tencent_with_me/"/>
    <id>https://wangzhike.github.io/2020/03/08/tencent_with_me/</id>
    <published>2020-03-08T17:34:25.000Z</published>
    <updated>2020-10-18T15:44:14.929Z</updated>
    
    <content type="html"><![CDATA[<p>2019年7月13号，作为一名校招生，我在腾讯滨海大厦办理新员工入职。那时的我，离开校园没多久，怀揣着对未来的很多期待，少年气十足。看到自己所在的是游戏接入组，虽然也多少担心即将要从事的游戏AI后台开发跟游戏会有多大的牵扯，但心里还是比较乐观。也不容我多想，当天就前往金百合酒店开始为期一周的封培。</p><a id="more"></a><img src="/2020/03/08/tencent_with_me/welcome_to_tecnet.JPG" width="30%" height="30%"><h2 id="1-封培与新人培训"><a href="#1-封培与新人培训" class="headerlink" title="1. 封培与新人培训"></a>1. 封培与新人培训</h2><p>坐大巴前往金百合的路上，班主任正在点名，我忽然收到了牛客好友小G的微信，说听到了我的名字，问我俩是不是在同一个班级。我和小G是通过我在牛客网发的一个offer比较贴认识的，当时我在腾讯游戏后台和京东广告部后台之间考虑，犹豫是选择腾讯这个很贴心也更大的平台还是选择京东更感兴趣的广告方向。小G给我评论了，然后我俩加了微信。当时小G跟我说，他也是对游戏不感兴趣，觉得游戏开发没意思，也找不到从事游戏业务的价值，所以尽管他拿了网易游戏将近40w的大sp，也拒掉了。小G鼓励我说，让我选择感兴趣的工作，方向大于公司，他说就类似于选学校和专业，专业更重要一些，他最近看到一些清北非CS的被人吊打，深感如此。和小G聊过，加上我自己原有的判断，当时我婉拒了腾讯游戏实习组里的机会，和京东签了三方。</p><p>后面又来腾讯，也是机缘巧合，先是京东那边因为组织架构调整，我最初被通知要调岗，后面联系又说可以不调岗，因为选择京东就是出于兴趣，要是被调岗了，我感到很不稳定，所以临近毕业前我又重新试着投了简历。正好也赶上腾讯这边联系我参加补录，最后就选择了现在这个组。</p><p>对于我重新回到腾讯，小G也很开心，毕竟从素未谋面到一起参加封培，怎么说都充满了因缘际会。小G好像也问了我新的工作内容，我告诉他是游戏AI后台，虽然我心里也不清楚新工作和游戏会有多大耦合，但我还是主动安慰小G说，业务是游戏不至于太边缘，做的估计是AI基础设施的后台，应该和游戏关系不大。</p><p>能和小G见面，我感到很幸运，遗憾的是我和小G没有分在同一个小组。我所在的小组也很好，我们有一个特别诗意的队名“一棵朱菏向鸣溪”，队名是从组里8个人的名字里面各选择一个字组成的。我们小组配合也很好，在两三个游戏里面都拿到了第一名。</p><p>封培期间，比较有意思的一个活动，是班主任发起的“国王与天使”的游戏。班里每个人都是天使，抽签得到国王的名字，然后想办法做一些让国王开心的事情。这样，天使同时也是另一个人的国王，在付出的同时也能够收获另一个人的关心。游戏中，我收到了天使送来的奶茶和糕点，我也给国王送出了果盘和奶茶。这个游戏让我意识到人与人之间的相处，如果能够先做到利他，很自然会得到利己的结果。我们应该多关心周围的人。</p><p>封培也有幸参加了两门很有价值的课程。一个是讲互联网各个方向的发展历程，包括及时通讯、网络媒体、电商、云、搜索，老师的梳理和见解，让我第一次看明白了互联网的全貌，也让我认识到独立思考、复盘总结的重要性。另一个是鹅厂老兵的分享，分享人波哥对于工作选择的回答让我印象深刻，他说“年轻时，可能看不清形势，但可以清楚自己的兴趣激情和局限，做适合自己的事情。要有好奇心和理想主义，但要分步骤一步步实现理想。趁年轻的三五年，可以多承担风险，多尝试多试错，30岁之前找到自己最有激情最适合自己的行业岗位。”。今天来看，波哥的话在一定程度上指导着我的选择，希望自己可以保持好奇心和理想主义，一步步去实现自己的价值。</p><p>封培结束，在组里做了将近一个月的ABTest系统，我又迎来了部门的新人培训。培训分为三个方向：强化学习、搜索和运营。强化学习是部门的主要方向，游戏AI主要使用强化来做。部门的前身是搜搜，部门目前仍有一个中心负责搜索业务。运营是我所在的组讲授的，我也是到了组里才知道，我虽然是后台岗位，但是有很多运营相关的工作，包括运营网站系统建设、系统运营工具建设、离线运营日报维护等。自己在做ABTest系统期间，多少已经觉得自己对运营这块不太感兴趣，但好在没有接触到和游戏直接相关的工作，觉得工作还能接受。</p><p>新人培训期间的最大收获，就是在参加搜索项目培训时，我第一次了解到了搜索这个方向。我很惊讶，竟然有这个一个方向可以纯粹做服务端的工作，和游戏也没有任何关系。我非常激动也很开心，在做搜索项目的过程中，虽然有压力也比较累，但是我整个人很亢奋，对要实现的内存索引系统充满了兴趣和干劲，索引结构设计、共享内存使用、PB协议……，这些细节吸引着我，我乐在其中。最后项目要结束前，我觉得有些怅然若失，甚至有些不想面对接下来的运营项目和组里的运营工作。</p><p>也是在新人培训期间，为了尽可能好地完成项目，我们两个小组到滨海进行封闭开发。这个过程中，我结识了包括小A、小红、小K、小Y在内的好朋友，这些小伙伴也成为接下来我工作生活中的良师益友。</p><h2 id="2-与游戏相处"><a href="#2-与游戏相处" class="headerlink" title="2. 与游戏相处"></a>2. 与游戏相处</h2><p>新人培训结束的两个月里，我主要负责运营日报的维护。这块工作主要是从hive集群中，写sql语句查询出游戏的各种离线指标，比如日游戏局数、英雄KDA、英雄胜率等。将查询到的统计结果写入到mysql，php脚本查询mysql数据，以json形式返回给前端做可视化展示。之前在学校里，sql语句我基本没有怎么接触，这就需要一点点啃sql语法。由于游戏的数据量很大，所需的查询信息可能分散在多个表中，需要进行各种<code>join</code>操作，最开始接触时，一两百行的sql里面含有五六个<code>join</code>操作，确实让我一下子很难完全消化。而且，由于我对游戏的抵触，面对要查询的各种游戏指标我感到很头疼，一开始真的不知道该如何查找这些内容。</p><p>面对这两个困难，我先补充了下sql语法知识，尽可能搞明白基础的<code>select</code>、<code>where</code>、<code>join</code>的用法。也调整自己的心态，将游戏指标看成普通的指标，通过查看hive表结构以及现有的查询脚本，试着编写新指标的查询脚本。就这样，一步步适应了这个工作。这个过程中，在查询ABTest指定版本指标时，我导师先单独将指定版本的对局信息拿出来，然后和其他数据表做<code>join</code>操作，以排除其他版本信息的做法，当时让我眼前一亮，让我意识到sql中的大局观意识。</p><p>在维护日报的过程中，我感觉很枯燥。由于毕设使用go实现raft，里面用到了协程和同步机制，让我特别渴望在工作中接触到并发服务端编程的内容。当时的工作不但接触不到这些，而且是一直写sql、python等脚本，干着运维或运营的工作，这种心理落差让我很难受，有些担心这种状态一直持续下去，自己对技术的热情会被逐渐消磨掉。面对这种情况，维护日报一个多月后，做完手头最近的需求，我向导师委婉表达了想接触下其他工作内容的想法。本以为接下来可以接触一点服务端的内容，但是没想到要做的是游戏客户端相关的内容。由于强化训练需要数据，这些数据对应游戏客户端里面的各种字段，所以需要根据需求，将游戏客户端里面的指定字段信息提取出来，以PB格式传递给AIServer，来进行训练和预测。我接下来的工作就是为技能添加新的字段信息。面对这个新的工作，我内心特别崩溃。这是我最抗拒的工作内容，需要去看游戏客户端的代码，搞清楚游戏本身的实现逻辑，然后从游戏复杂的数据结构中提取出需要的字段信息。而且开发环境是在windows下，需要使用visual studio进行开发，由于我使用的是mac，我还需要专门跑到组里其他机器的位置看代码和开发需求，这更加剧了我的抵触和厌恶。</p><p>面对需求，我无法选择逃避，只能硬着头皮看游戏客户端的代码，一边看一边画思维导图，试着梳理出技能对应的数据结构。尽管我强迫自己去完成工作，但是我个人状态确实因为这个比较受影响，不仅觉得工作枯燥，更变得抵触与厌恶。面对这种情况，我和研究生同学小Z交流，表达了工作上的困境。小Z刚从百度离职，原因也是工作中一直做前端这块，觉得不对口。对于我的情况，小Z建议我可以试着看一看外面的机会。对于朋友的提议，我当时还不太想这么就放弃，我说再试一试，心想既然接触不到服务端的内容，从现在开始我自己抽时间看这方面的内容。</p><p>有了这个打算后，我也开始抽时间看服务端的内容。但是，组里面的工作又很饱和，每天留给我的空闲时间很少，有的时候忙到晚上10点多才下班，很难做到每天补充一些服务端的知识。这种挫败感让我心里很难受，多少有一种无法把控自己的感觉。好不容易挨到周末，想抽出时间学习下，但是周内压制自己做游戏客户端的开发，心里面的情绪积攒起来无法排解，加上忙着工作没有时间放松，周五晚上我又犯了熬夜的坏习惯，有好几次都通宵看电视剧排解烦恼，享受周五静谧的夜里短暂又难得的轻松。这样自然周末也荒废了，熬夜看看剧睡个懒觉，恍恍惚惚周末就过去了。形成这样的消极状态后，周末也无法学习，更加剧了自己的挫败感。</p><p>十一期间，我曾找几个师兄交流自己现在的工作状态。其中Y师兄的话有些说服了我，师兄并没有否定我对游戏的个人喜好，强调能学到东西的工作就有继续做下去的价值，要有正确的工作观念，要培养自己的方法论，发现工作中用到的技术的价值，不感兴趣不影响建立方法论和学好工作中的技术。师兄也强调不要把目前的状态看得太严重，这只是暂时的，以后职业生涯还很长，不会一直这样。师兄建议我继续坚持一段时间，看清楚自己对工作的态度是什么，也思考清楚自己真正想做的业务和技术方向。如果不合适，到时脱坑也可以。</p><p>师兄的话很有用也很及时，像一剂良药缓解了我当时糟糕的心态，让我有信心可以继续坚持下去。但是十一过后工作上并没有很大改观，由于新的需求很紧急，我又做了一个月的日报开发工作，而且后面的日报维护工作也都转到了我这边。周会上组长甚至表示想让我后续做更多游戏客户端方面的开发，这让我对后面的工作方向有些悲观。加上工作依然很忙，之前周内忙碌周末熬夜的状态也没有改变过来，导致我开始考虑寻找外部的机会。</p><p>这个时候，我和研究生的另一个朋友小F聊了下自己的困惑，中间提到了搜索的新人培训项目，说自己对搜索挺感兴趣的。小F是做推荐算法的，他告诉我推荐、广告的后台和搜索很像，但是目前推荐和广告比搜索应用场景更广，建议我考虑下推荐或者广告的后台。听小F介绍了下推荐这块的内容，我也自己大致了解了下推荐和广告的后台岗位内容，我决定接下来就做推荐或者广告方向的后台开发。</p><p>在研究生同学小Z和小F的鼓励下，我开始投递这方面的岗位，包括头条和爱奇艺的广告部门、京东商城的推荐部门。毕业半年多，之前面试刷题的知识忘记了一大半，最开始我心里也很担心自己能不能通过面试。在发小的支持下，我重新翻开《剑指offer》，开始刷题，回顾之前做的搜索项目以及raft毕设。准备和面试前后花了两个多星期，最后很幸运拿到了爱奇艺广告和京东商城推荐的后台开发offer。</p><h2 id="3-反反复复的去留抉择"><a href="#3-反反复复的去留抉择" class="headerlink" title="3. 反反复复的去留抉择"></a>3. 反反复复的去留抉择</h2><p>在收到了爱奇艺和京东的offer后，我开始真正考虑去留的问题。在爱奇艺和京东的选择上，由于爱奇艺这边给offer比较晚，和朋友小F交流后，他觉得不论是从公司体量、物料丰富度还是流程效果上，京东推荐都要优于爱奇艺广告，我自己觉得单从业务上来说，推荐应该要比广告更直观一点，所以拒掉了爱奇艺接受了京东的offer。但是一旦真要做出离开腾讯的决定，我心里突然又觉得很不舍。一方面，鹅厂的人文关怀和员工福利没得说，公司同事之间自由瑞雪的氛围，让我不舍。另一方面，腾讯的平台也很耀眼，相比之前，京东的平台没有腾讯大，而且因为东哥的高调，京东的口碑也不是很好，加上校招那次被京东调岗过，对京东这边也不太有信心。但是，我心里真的很想转变当时不好的状态，对推荐这个方向也很期待，到底是去还是留让我很纠结。</p><p>面对选择，我请教了对我影响很大的W老师。实习那会面对游戏后台的留用时，我就咨询过W老师。老师当时问我游戏业务是不是自己感兴趣有优势的方向，最好要在工作中找到一点，在这一点上其他同事都比不上自己。我向W老师说明了自己的情况，明确腾讯这边目前的工作自己没有热情，京东推荐是自己想做的方向，但是目前工作只有5个多月，跳槽的话简历不好看，而且以后估计很难再回流腾讯。老师告诉我要考虑几个方面，一是京东的发展如何，二是京东要去的部门尽可能多了解清楚，是否符合自己的期望，三是推荐系统主要是软件和算法，机器学习这些，自己是否有兴趣和优势。对于去留，老师让我再看看腾讯内部是否还有其他机会可以提前联系，有的话就留在腾讯，没有的话，可以考虑马上去京东，主张把个人兴趣放在第一位。听完W老师的建议，我心里面坚定了去京东的想法，决定下周上班就和组长说离职的事情。</p><p>我也加了京东这边和我一个大组但不同小组的同学L的微信。L跟我说去年部门刚经过调整，换掉了一批人浮于事的员工，现在组里确实比较缺人。部门的氛围挺不错的，同事人都挺好的。而且L觉得他所在的小组技术挺好的，我所在小组的组长S哥能力很强，我所在小组的技术应该也不差。单从部门氛围和技术上来看，部门其实挺好的。但是L也说，京东这边额外的员工福利几乎没有，让我有个心理准备。听了L的介绍，我对京东这边组里的情况基本比较放心，我比较在意的主要就是部门氛围和技术水平，这两点不错的话，有没有额外福利我都可以接受。</p><p>周末，小红邀请我、小A、小K去她那做客，也认识了小红的室友小绿。这期间我和他们说了自己离开的想法。小A是本硕都在澳洲读的留学大佬，对很多事情的看法都比较深刻。小A不太建议我这时候跳槽，因为他觉得工作不满一年跳槽，怎么说都是简历上的污点。京东的平台确实比腾讯要差，而且京东的薪资也没有比腾讯现在高很多。不如在腾讯待满一年，到时简历是加分项，而且不论是内部转岗还是跳槽，选择都要多很多。听了小A的分析，确实很有道理，我又觉得是应该理性一点。而且，我也舍不得离开这些朋友们，对离开的想法有些动摇。</p><p>兴趣还是理性，我一时拿不定主意。我试着回顾自己大学以来的学习经历，发现自己的兴趣是能让自己感受到美和逻辑的事物，文学、编程都属于这种，游戏显然不是自己的兴趣。自己的优势在于，能在兴趣之上，从原理出发，理论联系实际，前后对比串联，形成自己的知识体系并实践验证。总体来说自己应该选择有兴趣且有理论支撑的方向。这么看，游戏不适合自己，推荐系统是一个不错的方向。有了这个思考之后，我心里不再那么慌乱，对于选择有了一份底气，但是还是无法做出决定。</p><p>让我决定留下来，是另一位师兄，他的微信名叫马作的卢飞快。师兄是一个特别有才华的人，阅读量非常大，写的一手好文章，让人非常佩服，而且他最近刚从华为跳槽到阿里。面对选择，我大胆联系了师兄。那天晚上和师兄聊了不少，师兄的看法是最好留下来，因为从他这次的跳槽经历看，公司平台真的很重要，腾讯平台很好，不应该放弃这个优势，工作前几年要跳槽也在几个头部大公司之间跳，京东目前还不属于这些头部公司。对于工作，他觉得心态要好一点，工作是工作，生活是生活，不能让工作影响生活和心情。再坚持坚持，尽量在工作中找到吸引自己的内容。听了师兄的意见，加上对腾讯的不舍，我决定留下来，婉拒了京东这边。</p><p>既然决定留下来，我重新调整好自己的心态，也期望后面能接触到一些服务端的内容。留下来的第一周，我导师说虎牙自由ob的项目要开始了，让我参与进去，体会一个完整的项目流程。由于虎牙是一个新业务，需要搭建一个新的后台集群，当前线上的模块代码基本不用改动，只需要更新下iplist等配置。对于集群配置的更新部署，我挺有兴趣的，至少通过这个机会我可以了解下组里目前服务端模块的结构。可以说，留下来的第一周，我挺开心的，也充满干劲。</p><p>但是好景不长，第二周开始，我先负责给虎牙提供游戏的实时数据格式，里面涉及到各种游戏指标数据，小兵的信息列表，野怪的信息列表，塔的位置血量，英雄的技能、大招，大小龙的信息列表。既然选择留下来，我也明白，这些内容是不逃避不了的，我也就笨手笨脚的一一去填充核对。但是接下来的工作却远超我的想象和忍耐程度。</p><p>由于要给虎牙提供4k的视频流，需要先调试好对应的显卡配置。所以我接着研究如何将TESLA P40的显卡由计算模式切换到图形渲染模式。这个模式切换并不简单，我网上搜索了半天，才了解到要启动图形模式，需要NVIDIA的许可证。为了获取NVIDIA的临时许可证，我先用自己的工作邮箱申请试用，但是当天并没有得到NVIDIA的审核。联调时间不等人，我又联系了公司负责显卡业务的同事，拿到了他们的许可证信息，一步步参照网上资料研究如何使用该许可证。面对这个工作，我感觉有些无奈，我觉得这不是组里的本职工作，类似这样的问题应该由公司内部专门负责机器配置的同事解决更好，但是没办法我只能一步步向前艰难推进。最后还是成功将显卡切换到了计算模式。</p><p>完成了显卡配置，我以为可以松一口气了，但是还有更繁琐的工作在等着我。由于向虎牙提供的4k视频流，要求帧率稳定在30fps。我们目前使用的ffmpeg推流方案，帧率最高在10左右，远远达不到要求。面对这个情况，我以为组里会把这个问题转交给公司内部专门负责视频编解码的同事解决，没想到还是我们自己研究解决办法。由我配合虎牙那边视频编解码的同事，通过更改ffpmeg的推流参数，试着提升帧率。由于推流环境在公司内网，虎牙这边无法访问，我作为对接人，工作就是在推流环境尝试虎牙提供的各种推流参数。留下来第二周的剩余时间里，我的工作基本都是虎牙同事提供一个推流参数，我在内网推流环境进行测试，帧率得不到提高，将结果反馈给虎牙。那时候，整个项目卡在帧率提升上，我觉得自己像是一个外包人员，做的工作没有任何技术。看到小A开始接触组里的线上模块，我很羡慕。这时候刚好线上模块有个功能需要改进，组里觉得小A一个人干也有些吃力。我和小A商量，看看能不能请求我俩把这个需求接下来，一起完成这个工作。于是，在中午吃饭的时候，我向组里表明了自己想和小A一起完成线上这个新功能的想法，没想到立刻被否决了，组里觉得我在做虎牙这个项目，没有时间完成这个。虎牙这个项目遇到组里不擅长方向的问题，我一个人和虎牙对接，感到无力又觉得没有成长。另一方面，接触线上服务端模块的想法也被否决掉，让我有些失落。想到接下来还需要为虎牙提供详细的游戏实时数据，这块内容更是我抵触，一时间我觉得看不到希望，有些抗不下去。</p><p>这时候离拒掉京东已经过去两周了，面对自己的现状，我有些后悔留下来的决定。想到京东面试官S哥说有问题还可以联系他，我有些想再次联系京东试试。当时的现状让我觉得支撑不下去，另外发小L准备去北京，我之前就很期待和发小L在一个城市奋斗，这样就算现在不走，满一年之后我也很可能去北京。想到这些，我觉得要是能重新挽回京东的机会，能省去半年时间，也能改变我的现状。以目前这种不好的状态，满一年之后我内部调岗还是跳槽，技术上能有多大提升，能获得什么要的岗位，我自己也没有信心。现在能追回京东的offer，对我而言算是一个好结果。想到这些，我很后悔拒了京东，也很想再次联系京东试试。我和另一个发小G说了这个想法，G觉得可以试一试。我和爸妈也说了这个想法，感觉到他们听了有些担心。细问下来，他们才说出因为家里今年盖新房，比较需要钱。现在12月中旬了，我现在去京东，腾讯这边的年终奖就没有了，损失了的年终奖对家里来说也不是小数目，觉得有些可惜。但是他们也不想限制我追求自己的兴趣。他们也是前后为难。面对爸妈的苦恼，我当时想，还是要联系京东，但是直接说因为家里需要钱，我得等拿了年终奖才能走，也就是要到年后才能入职。和爸妈说了这个想法，他们觉得这样可以，算是两方面都兼顾。就这样，我联系了京东，对自己前后反复的行为表示后悔和不好意思，也表明了需要拿了年终奖年后才能入职的要求。没想到京东面试官S哥表示也理解我的行为，并将我的情况反馈给了组长M和hr小姐姐X，让我先耐心等消息。在等消息的几天里，我很忐忑，我又主动联系了组长M，表达了自己前后反复的羞愧，自己对推荐的兴趣，想挽回这边的工作机会。组长M说也很理解我，并且看我态度谦卑，她还说自己压力也很大，她说如果我真的来了京东这边也希望京东的工作能满足我的发展需要，她也表示客观来说京东的平台不如腾讯，但是京东的推荐业务是非常核心的，而且已经有一定的积累，对于刚工作的同学来说她觉得还是能学到不少东西的。听了组长M的话，我觉得有些不好意思，自己又有什么资格能得到对方这样的坦诚相待，我应该感念这份真诚。我也联系了hr小姐姐X。我记得那天正好是公司年会，抽到票的同事都去了现场，我是为数不多留在公司的人。那天晚上电话里我吞吞吐吐地表达着自己的不好意思，自己的后悔，我也说自己可以以实习生的身份先过去工作一段时间，以证明自己可以做好这份工作。小姐姐X听了我的话，也表示理解我的想法，还开玩笑说我这么吞吞吐吐，好像跟表白一样。她说offer可以挽回，也不用我去实习，岗位待遇和之前都一样，但是她也再次向我确认，这次我想好了吧，不会再有什么变化吧。我连连肯定小姐姐，也表示很荣幸可以亡羊补牢，会好好珍惜这个失而复得的工作机会。</p><p>就这样，兜了一圈之后，我再次选择京东。而且这次，是我主动联系的京东这边，坦言了自己前后反复的不好意思和愧疚，自己放弃offer的后悔。对于京东部门同事和hr的理解与大度，我心里很感激。我告诉自己，这样的部门一定不会差，有这样部门的公司也不会差。这次重新选择京东，我暂时没打算告诉小A、小K和小红他们，一方面是觉得自己前后反复不太好意思，另一方面也是不想再受外部影响，比较坚定新的决定。</p><h2 id="4-疫情下的交接"><a href="#4-疫情下的交接" class="headerlink" title="4. 疫情下的交接"></a>4. 疫情下的交接</h2><p>重新得到京东这边的offer之后，我心里面有了希望，变得很平静。虎牙项目4k、30fps的推流问题移交给了虎牙那边的同事，由他们专门去解决。我开始着手进行实时数据的开发工作，尽管我心里还是很抵触这个工作，但是有了新的希望，眼前的痛苦也就不再令我害怕。由于实时数据需要以json格式传递，游戏这边使用rapidjson作为json库，我就研究了下rapidjson的使用。实时数据需要以http post形式发送，我又寻找windows平台下的http客户端库，最后选用<code>curl</code>来发送post请求。又由于<code>curl</code>发送请求是阻塞的，发送一次请求的耗时超过了游戏的帧间隔，我又研究了游戏客户端自身的线程库使用，采用线程池的形式来实现异步发送post请求。这个过程中，挑战很多，也很累，晚上经常加班到11点多，但看着项目一步步推进，心里面也挺开心的。完成了实时数据发送的问题，虎牙这边也提供了obs取代ffmpeg进行视频流推流，我继续处理视频流这块的事情。使用虎牙提供的obs，可以实现推送4k、30fps的视频流，但是腾讯云的推流链接最大只能将码率提升到5k左右，而虎牙希望提供10M的码率。将腾讯云的推流链接换成阿里云和虎牙自己的链接，码率都可以达到10M，所以定位问题应该出在腾讯云的推流服务上。年前的最后几天，我导师已经提前请假回家了，我想到年后一来就要提离职了，所以选择了晚走，并配合虎牙以及腾讯云的同事，一起定位推流服务码率无法提升的问题，发现是腾讯云这边对rtmp协议的帧大小进行了限制，在测试机器上放开了帧限制后，码率可以提升到10M。</p><p>等我年前回家的时候，疫情已经开始有些严重了。走之前的两天，每天都从公司行政那里领取口罩，加上回家当天小K也给了我一个3M的口罩，保证了回家路上口罩够用。等到家之后，疫情已经很严重了，老家村里开始封路，每天广播疫情防控信息，往年串亲戚、聚会等活动也都停止了。春节那几天，我在家里难得清闲，可能是由于这半年工作的不顺心，我心态上很懒散，什么也不想干，每天除了和发小一起聊天，就是看看剧，日子过得悠哉悠哉，但心里对选择京东还是缺乏信心。这期间也认真回顾了半年的工作经历，认识到这半年的工作状态确实不算好的工作状态。当时总结到好的工作状态要满足三点，一是工作和生活有个平衡，而我这半年工作占用了本来就不多的生活时间，导致没有生活。二是工作上或多或少要有一点自己感兴趣的点，吸引着自己可以投入进去，显然我对当前的工作没有兴趣。三是工作待遇还不错，努力工作也能得到认可。而我年前认真完成虎牙的项目，但在组长看来虎牙这个工作并不是组里的主要工作，希望我可以早点脱身出来，这样说多少有些否定我在其中的认真付出。这样分析过后，让我更坚定了离开的想法。</p><p>在家期间，和爸妈进一步说明换工作的原因，也表达了对选择京东未来不确定性的担心。和爸妈多次讨论后，他们觉得选择自己感兴趣的，这个出发点就足够了。虽然说再等半年可以在腾讯内部转岗，但是选择京东可以提前接触自己感兴趣的方向，一步到位。而且第二次是自己主动联系京东，京东又给了机会，出于诚信也应该过去。兴趣加情感，让我坚定选择京东。</p><p>由于疫情的影响，原本不到10天的春节假期，一再延迟。最开始我比较高兴，毕竟可以在家多待几天。但是随着假期一天天延长，以及后面在家办公，我有些着急了，我必须尽快和组长沟通我要离职的想法。为了稳妥起见，我先和京东这边的hr小姐姐x和组里的S哥都说明了下自己目前的情况，表示最近就和腾讯组长沟通离职意向，他们表示由于疫情，时间上没问题。和京东沟通好了之后，我先和导师说了要离职的想法，其实去年考虑去留时我就和导师聊过一次，导师当时让我多问问周围人，综合考虑，去留都没关系。这次和导师表明我要离开，导师还是有些意外，不过也表示理解我。接着我和组长沟通了要离职的原因，主要表明自己的兴趣不在游戏业务上，对京东那边的推荐更感兴趣。也说明了自己先拒绝京东然后又找京东要回机会的前后过程，表示自己也很感激京东这边把工作机会给我保留到年后。但是组长并不认同我的想法，他觉得对游戏不感兴趣可以给我少分配这方面的工作，想做服务端的工作也可以给我调整，让我不要这么快做决定，他先给我调整下工作内容，让我也进一步考虑下。听到组长这么说，我也不好再拒绝，我就按照组长调整后的分工，接着干了两个星期。和组长聊完后，组长又让我导师来劝一劝我。导师跟我直言是组长让他来挽留下我，他说让我自己再考虑下，但是要果断一点做决定。我跟导师说因为工作调整，他的一部分工作被调到了我这边，我感觉很不好意思，觉得影响了组里正常的工作节奏，导师说这个不用放在心上，让我当成正常的工作分配就好。他也说留下来也可以，选择去京东做自己喜欢的业务也不错。组长的挽留确实让我没有想到，工作调整后也多少符合了我的想法，这让我有些动摇。和爸妈以及发小讨论后，还是觉得出于兴趣和感情，都应该坚定京东。出于善始善终的考虑，我还是按照组里新的分工开展工作，尽可能好地完成任务。</p><p>两个星期后，回到深圳，我再次给组长发消息，表明经过两个星期的调整与尝试，还是想跟随自己的兴趣，看一看自己在感兴趣的方向上能做到什么样子，决定选择离开，对公司和组里只有不舍和愧歉。组长回复说这也应该是我最后的决定了，他向部门经理说明下我的情况。组长和经理沟通后，跟我说经理觉得不感兴趣离开也可以，不过也可以让我内部调动到搜索那边，让我考虑下。这个提议让我觉得又吃惊又荣幸，但是想到承诺了京东这边，我虽然很心动但是还是当面婉拒了组长。不过虽然拒绝了组长的提议，但是我心里面却无法平静，我必须调整自己的心态，让自己可以从容面对这个选择。</p><p>这个问题上真的很感谢熬友小T，叫小T为熬友，是因为年里认识的时候，我和她约了某个周五晚上一起熬夜，看谁先坚持不住。过年期间我就和小T提过自己换工作的事情，借着这个机会，我向小T仔细说明了自己的想法，我告诉她我很不舍腾讯的公司文化，对于由于工作不满一年以后无法再回腾讯，真的很难接受。作为农村出来的孩子，我们害怕犯错误也尽量避免犯错误，我也担心去京东不顺利的话，会让自己陷入困境，要是这样的话担心自己走不出来。但是接受提议留下来，尽管搜索业务也很符合我的兴趣，但是这样做的话觉得是做了亏心事，违背了说过的话，有愧于京东这个和我接触过的人。小T听了我的话，也替我很纠结，但是她说留在腾讯我不敢保证过的一定是自己想要的，如果不是自己想象中的样子，我的痛苦会加倍。这个过程中，她也听了我对过去一年京东的分析，她认为京东也不错，选择去京东并不是犯错误，也会有发展。字里行间，我能感受到小T在鼓励我勇敢一点，让我坚定自己的选择，只要踏实认真，一步一个脚印，我在京东也会顺顺利利，实现自己的追求。</p><p>发小G也鼓励我选择京东。他认为面对内部调动的提议，我应该更加坚定，这也是一个考验，让我更加认识到坚持原则的重要性。他认为现在的决定，也会影响我以后的选择，同时也会对我身边的人产生影响，希望我可以践行自己说过的话，不让京东这边跟我接触的人失望。</p><p>熬友小T以及发小G的分析鼓励，和我心里的想法一致，这个时候我还有很多负担影响我做选择，我应该坚持自己长期以来的秉性原则，选择京东。出于兴趣和情感，我都应该去京东勇敢试一试。</p><p>理清楚了自己的想法之后，我正式在系统提交了离职申请。那天晚上离职理由我写了好久，想表达出渴望追求兴趣的想法、对公司的不舍与愧疚、对内部调动提议的感激和心动、自己前后两次联系京东的原因，以及第二次主动联系京东挽回机会，约定年后过去的承诺。表明自己婉拒内部调动的提议，是为了不违背自己对京东的承诺，算是践行正直的价值观。</p><p>在系统提交了离职申请后，周末我约小A、小K、小红、小绿、小Y在海底捞吃了散伙饭，那天晚上大家聊了很多，回家前互相告别，都当作正式的道别一样。工作上我也开始好好收尾虎牙这边的工作。打包PC档，配合虎牙进行比赛服调试，根据需要修改虎牙模块代码，我尽可能多解决虎牙这块的问题，同时也尽可能将虎牙的交接文档写的详细些。离职前那天，我还在群里回复虎牙这边的问题。那天离开将电脑退库之后，我需要前往滨海交工卡，拿离职证明。离开之前，导师出来送我，组里面的同事也都站起来跟我道别，我心里是又温暖又难过。导师把我送到电梯口，叮嘱我到了京东好好干。小A、小红、小K送我到楼下，我们像往常一样闲聊着等车，但是谁都知道这是接下来不短的时间里我们的最后一次面对面聊天。他们看着我坐上出租车，挥手跟我道别，我说不出当时的滋味，有久违的解脱也有突然被割断的牵挂。顺利在下班之前感到滨海，交工卡，拿离职证明。走出滨海的那一刻，我开始明白曾经作为这里一员的我必须要告别了，我得接收这种瞬间转变的陌生感，跟鹅厂正式告别。江湖虽大，有缘再见！</p><img src="/2020/03/08/tencent_with_me/tencent.jpeg" width="95%"><h2 id="5-北京与京东"><a href="#5-北京与京东" class="headerlink" title="5. 北京与京东"></a>5. 北京与京东</h2><p>对于北京和京东，有我最真挚的朋友，有我期待的工作，也有我看不清的路。这一路走来，有太多的朋友、老师、同事以及家人听我倾诉，给我指导，我只能把这些情谊放在心底，化作为前行的动力。我会牢记W师兄的提醒，工作两年应该有工作两年的能力，自己想做的工作要靠努力去争取。还有J姐的鼓励，到了京东就不要再这么任性了，京东也是个好公司，好好工作。</p><p>前路漫漫，未来的进退得失，已不在于已做的选择，在于自己的脚步。愿朋友们一起，相互勉励，砥砺求知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年7月13号，作为一名校招生，我在腾讯滨海大厦办理新员工入职。那时的我，离开校园没多久，怀揣着对未来的很多期待，少年气十足。看到自己所在的是游戏接入组，虽然也多少担心即将要从事的游戏AI后台开发跟游戏会有多大的牵扯，但心里还是比较乐观。也不容我多想，当天就前往金百合酒店开始为期一周的封培。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
